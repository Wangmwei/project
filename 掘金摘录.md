### 1、前端性能优化

前端性能优化：减少消耗，提高用户体验。

① 减少请求数量。合理规划利用请求，合理利用缓存技术减少不必要的频繁请求。及时性不高的数据可以缓存起来利用，

例如一些基础数据。应用懒加载技术，按需加载，缩短首屏或页面首次加载发起的请求数量，缩短等待时间和渲染时间。

② 缩短请求时间

打包压缩文件，压缩js和css文件，减小文件体积，缩短加载时间

③ 优化资源加载方式。script加载。考虑异步请求资源，合理利用script加载方式，script脚本的执行只在默认的情况下是同步和阻塞的

script有defer和async属性（延迟和异步），这可以改变脚本的执行方式。

css加载。合理规划css的加载引入方式，减少@import的使用，页面被加载时，link会同时被夹在，而@import引入的css会等到页面加载完再加载。css尽量放在head中先加载，减少首次渲染时间。

一些用户操作行为用到的资源，可不再初始化时加载，合理延迟或有需要才请求。

④ 减少重排(reflow)重绘(repaint)

减少不必要的DOM深度，例如不必要的嵌套结构，在DOM树中的一个级别进行更改可能会导致该树的所有级别（上至根节点，下至所修改节点的子级）都随之变化。这会导致花费更多的时间来执行重排。

尽可能减少css规则的数量，并删除未使用到的css规则，一些默认就有的css规则，就不必写了，具有继承性的样式，也不必每级节点都写。calc()之类的计算方法应该少用

⑤ 函数防抖与节流 

限制某些不必要的行为的频繁触发

###  2、简述一下你对HTML语义化的理解

合理使用标签，用正确的标签做正确的事情：

可读性。代码结构清晰，便于理解，对人和机器的可读性都更好。

可维护和团队协作。清晰语义化的结构，可维护性更高，有利于团队协作。

seo。有利于搜索引擎优化（seo）

常见语义化标签：

h1-h6,header,footer,main,nav,title,article,time,progress,aside,strong,ul,ol等

### 3、html中的label可以用来干什么

label有两种使用方式，一是嵌套，二是通过id绑定。它可以用于关联绑定表单组件，浏览器会将用户对label关联范围的焦点转移到绑定的表单组件上

### 4、html全局属性（global attribute)有哪些

id：元素id，同一文档内id不能重复，具有唯一性。

dir:设置元素文本方向

lang:使用的语言

style：行内css样式

class:元素的样式类名

title:元素的提示文本，鼠标移到元素上时显示的一段提示文本

data-*：自定义元素属性。html规范提供的data-格式来写html元素的非标准属性

hidden:是否显示元素

tabindex：设置元素的tab键次序

dropzone：设置元素拖放类型（copy,move,link)

draggable:设置元素是否可拖拽

accesskey：设置快捷键，通过快捷键可激活相应的操作

### 5、html5引入了什么新的表单属性

url

number

email

month

date

week

datalist

time

datetime

range

### 6、img上title与alt

title是在悬浮时展示的提示文字，alt是在图像无法正常显示时展示的提示文字，此外，title是许多html标签都有的属性，而alt是img标签的特殊属性，当然在低版本ie浏览器中，鼠标悬浮也会显示alt的文字

### 7、职业规划

eg:坚持技术路线、往资深构架方向走，也希望拓展方向，向大前端靠近

###  8、从浏览器输入url到页面响应结束，这个过程是怎样的，js会阻塞文档渲染？

解析url的有效性和合法性

执行缓存策略，策略内缓存中有则从缓存取并显示

缓存中没有则发送请求协议，DNS解析域名，换取映射的ip地址

浏览器和服务器进行TCP连接，进行三次握手

握手成功正式发起请求，携带请求包，请求获取资源数据包

服务器接收处理请求包，寻找资源数据，并将资源数据返回给浏览器（当然可能啥也没有，也可能出错）

浏览器接收请求返回的资源数据，尝试解析数据

浏览器解析返回的资源数据过程：默认按照排序先后进行解析，加载head中的资源等，例如css

加载script脚本资源；script脚本的执行只在默认的情况下是同步和阻塞的。

script标签可以有defer和async属性（延迟和异步），这可以改变脚本的执行方式（在支持他们的浏览器）

继续解析后面的标签，文档内容

浏览器渲染页面，同时执行可能操作的异步请求

响应结束（可能正常显示，也可能异常）

### 9、关于head标签？head中必须的标签是什么？

head标签用于定义文档的头部。充当头部容器，script脚本，link资源，meta标签，

title标签用于定义文档的标题，它是head标签中唯一必须的元素

### 10、disabled和readonly的区别

readonly：元素的只读属性，可以防止用户对值进行修改，但用户仍然可以使用tab键切换到该字段，还可以选中或拷贝其文本。在表单组件input中使用readonly，内容会随着表单提交

disabled:禁用属性，使元素无法使用和无法操作，无法被选中。在表单组件input中使用disabled，内容不会随着表单提交

二者都可以通过js修改其值，从而恢复编辑状态和被选中能力

#### 11、TDK是什么，在前端优化SEO，应该从哪些方面着手

①TDK：title标题标签、description描述标签、keywords关键词标签

②SEO:

- ​	合理使用title、description、keywords:

title标题，description描述,keywords关键词的搜索影响权重是逐渐减小的。

title和description的内容应能代表网页内容，不能乱用不被普遍认可的词汇，不同页面title,description,keywords应不同，keywords的关键词，重要的靠前排放

- 语义化的html代码：符合W3C规范，语义化代码让搜索引擎容易理解网页
- 少用iframe：搜索引擎不会抓取iframe中的内容
- 网速：网站网速是搜索引擎排序的一个重要制表

### 12、介绍下重排reflow重绘repaint，以及如何进行优化。

- 重排或回流（reflow):

重排是在网络浏览器中执行的一个流程，用于重新计算文档中各元素的位置和几何形状，以便重新呈现该文档的部分内容或全部内容，会改变文档布局，会引发元素的位置，尺寸发生改变的行为可称为重排。重排比起重绘，在视觉效果上会更加明显，每当操作DOM树，更改影响布局的样式，更改元素的className属性或更改浏览器窗口大小时，都会发生重排现象

- 重绘（repaint)

在不改变文档布局的情况下，文档元素发生的例如背景颜色等外观改变的行为可称为重绘。根据Opera的说法，重绘的成本也很高，但在处理能力较高的现代设备中，可能感觉不明显

### 13、列举工作中常用的几个git命令

```javascript
git rm			删除工作区文件，并将这次删除放入暂存区
git add 		增加指定文件到暂存区
git init		新建初始化git代码库
git status		显示有变更的文件
git branch		列出所有分支
git commit -m [message]		提交暂存区到仓库区，可选填备注信息message
git checkout -b [branch]	新建分支，并切换到该分支
```

### 14、vue中组件之间可以怎样通信

- prop和$emit()

可以通过prop和emit()通信。在子组件通过prop接受父组件传递下来信息。父组件可以emit(name,data)向上派发的事件和传递的消息

refs和ref。ref绑定，refs获取组件实例，进而获取组件的属性，方法等信息。

vuex，可以通过vuex进行数据交互，状态管理。

Bus（中央事件总线）

### 15、vue指令中v-for和v-if哪个优先级更高

当它们处于同一结点，v-for的优先级比v-if更高，这意味着v-if将分别重复运行与每个v-for循环中

### 16、es6的了解

es6又称es2015,是js的标准它包含了许多新的语言特性和库，是比较大的一次升级

新增了：

- class
- 箭头函数
- 解构赋值
- 字符串模板
- async/await
- 引入module模块
- generators（生成器）

### 17、假如有10万数据要处理，前端应该怎样处理？

这题应该是想问虚拟列表，往时空错位方向考虑

分页获取分页渲染，也是一个朴素的好方法，但初次和面试官见面不好认真，还是虚拟列表把

- 虚拟列表

什么是虚拟列表：只对可见区域进行渲染，对非可见区域中的数据不渲染或部分渲染，以实现减少消耗，提高用户体验的技术。

为啥要用虚拟列表：一是性能优，二是体验丝滑，渲染生成过多的节点，可能会造成页面卡顿，甚至卡死浏览器，而常规分页的展示效果可能不是想要的，尤其是在移动端，用户习惯和偏好，更倾向于上下滑动

虚拟列表的实现思路：

- 可视区域固定高度，设置纵向Y轴滚动
- 计算可显示的列表项数量：根据可视区域和列表项高度，计算出可显示的列表项的书目Limit
- 当滚动条上滑时，计算出滚动的距离scrollTop
- 计算出当前起始索引：currentIndex=Math.floor(scrollTop/rowHeight)
- 计算出最后可显示的索引：endIndex=Math.min(currentIndex+limit,total-1)
- 渲染可视区域：根据开始位置startIndex和结束位置endIndex渲染可视区域

### 18、git和svn的区别在那里

- git和svn最大的区别在于git是分布式的，而svn是集中式的，因此我们不能在离线的情况下使用svn
- git分支上的变更不会影响其他人，svn分支上的变更会影响到其他人
- svn的指令相对于git来说要简单些，比git更容易上手
- svn中的分支是整个版本库复制的一份完整目录，而git的分支是指针指向某次提交，因此git的分支创建开销更小

### 19、说一说深拷贝？平时怎样实现深拷贝

- 浅拷贝：就是将一个对象的内存地址复制给另一个对象
- 深拷贝：先新建一个空对象，在内存中创建一个新的地址，然后把被复制对象的所有可枚举的属性方法一一复制过来
- 实现深拷贝的方法



①：JSON.parse(JSON.stringify(data)) ,但对于function 有缺陷

②：Object.assign()实现一层深拷贝

③：结构赋值法实现一层拷贝

④：创建新对象for循环拷贝，有需要可结合递归

大多数场景，还是JSON.parse(JSON.stringify(data))实用，虽然性能有所缺陷，但是每个字节所到之处都涉及性能问题吧

### 20、http状态码的301表示什么？你知道的http状态码有哪些？

##### ①状态码的职责：

状态码的职责是当客户端向服务器端发送请求时，描述返回的请求结果，借助状态码，用户可以知道服务器端是正常处理请求，还是出现了错误。

##### ②具体状态码的表示意思：

```
204 No Content 表示请求成功，但没有资源可返回，该状态码代表服务器接收的请求已成功处理，但在返回的响应报文中不含实体的主体部分，另外，也不允许返回任何实体的主体。
206 partial content 客户端进行了范围请求，服务器成功执行了部分的GET请求，响应报文中包含有Content-Range指定范围的实体内容
301 Moved Permanently 永久重定向。该状态码表示请求的资源已被分配了新的url，以后应使用该资源现在所指的url
302 Found 临时重定向。
303 See other
304 Not Modified
307 Temporary Redirect 临时重定向
400 Bad Request 语法错误
401 Unauthorized
403 Forbidden 
404 Not Found
500 Internal Server Error
503 Service Unavailable
```

### 21、防抖和节流

函数防抖动（debounce)：防止在短时间内过于频繁的执行相同的任务。当短时间内的频繁是不必要的时候，就可以考虑去抖动，避免资源浪费，或造成不好体验

函数防抖动的原理，主要是利用一次性定时器，延迟任务的执行，在延迟这段时间内，如果任务再次被触发，则通过clearTimeout销毁上一次产生的定时器，因为定时器的被销毁，；之前被延迟执行的任务也会随之被取消执行，这样就实现了在一定时间内，只执行一次任务。这一次的执行通常是最后一次的触发，因为此前的触发因为定时器的销毁而被取消了。

多次触发只执行最后一次或许就是和节流概念的区别？它两在作用上挺像，在具体是实现上略有不同，函数防抖（debounce)是短时间内连续多次触发，但只执行最后一次，即是说将多次执行变成了只执行最后一次，执行次数减少。而节流（throttle)是将短时间内的多次执行，变成每隔一段时间执行一次。

### 22、css的相对单位有哪些？px和em有什么不同？

- em	元素的字号，在font-size中使用是相对于父元素的字体大小，在其他属性中使用是相对于自身的字体大小，如width
- ex      字体的x字高（x-height)
- cap     字体中大写的标称高度
- ch     数字‘0’的宽度，元素字体中窄字体的平均字符前进，由’0‘字形表示
- ic      元素字体中全宽字形的平均字符前进
- rem    根元素的字体大小
- lh       元素的行高line-height
- rlh     根元素的行高
- vm     视口宽度的1%
- vh      视口高度的1%
- vi        根元素内联轴上视口大小的1%
- vb         根元素块轴上视口大小的1%
- vmin     视口较小尺寸的1%
- vmax    视口较大尺寸的1%

px和em的区别

px是css中的绝对单位，也是web前端最为常见的单位，它表示像素，它的值不会受到其他元素或其他值的影响，我们可以理解为10px所表示的意义，总是相同的。

em是相对单位，相对于元素的字号，在font-size中使用的是相对于父元素的字体大小，在其他属性中使用是相对于自身的字体大小，如width

相对单位的值的表示的大小，受其他东西的影响，比如1em，可能相当于10px的大小，也可能相当于100px，甚至更高，因为em的实际表示大小是根据父元素而定，1em表示的是父元素字体大小的一倍，要注意的是虽然只是受父元素的影响，但父元素也会受它的父元素的影响。











