### JS面试题
1、js的数据类型
    基本数据类型：
    number、string、Boolean、null、undefined、symbol、bigint
    引用数据类型
    object、array、date、function、regexp
2、js变量和函数声明的提升
    在js中变量和函数的声明会提升到最顶部执行
    函数的提升高于变量的提升
    函数内部如果用var声明了相同名称的外部变量，函数将不再向上寻找
    匿名函数不会提升
3、闭包
    闭包就是能够读取其他函数内部变量的函数
    闭包基本上就是一个函数内部返回一个函数
    好处：
    可以读取函数内部的变量
    将变量始终保持在内存中
    可以封装对象的私有属性和私有方法
    坏处：
    比较耗费内存、使用不当会造成内存溢出的问题
4、==和===的区别
    ==是非严格意义上的相等
    值相等就相等
    ===是 严格意义上的相等，会比较两边的数据类型和值的大小
    值和引用地址都相等才相等
5、this
    this总是指向函数的直接调用者
    如果有new关键字，this指向new出现的现象
    在事件中，this指向触发这个事件的对象
6、js数组和对象的遍历方法
    for in 
    for 
    forEach
    for-of
7、map和forEach的区别
    forEach方法，是最基本的方法，就是遍历与循环，默认有3个传参：分别是遍历的数组内容 item，数组索引 index，和当前遍历数组 array
    map方法，基本用法与forEach一致，但是不同的，它会返回一个新的数组，所以callback需要有return值，如果没有，会返回undefined
8、箭头函数和普通函数的区别
    函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象
    不可以当做构造函数，也就是说，不可以使用new命令，否则会抛出一个错误
    不可以使用arguments对象，该对象在函数体内不存在，如果要用，可以用reset参数代替
    不可以使用yield命令，因此箭头函数不能用作generator函数
9、同源策略
    同源指的是域名，协议，端口号相同
    跨域则是三者任意一个不同
10、如果解决跨域
    jsonp跨域
    document.domain + iframe跨域

    node.js中间件代理跨域
    后端在头部信息里面设置安全域名
11、严格模式的限制
    变量必须声明后再使用
    函数的参数不能有同名属性，否则报错
    不能使用with语句
    禁止this指向全局对象
12、es6新增
    新增模板字符串
    箭头函数
    for-of(用来遍历数据-例如数组中的值)
    es6将promise对象纳入规范，提供了原生的promise对象
    增加了let和const命令，用来声明变量
    还有就是引用module模块的概念
13、attribute和property的区别是什么？
    attribute是dom元素在文档中作为html标签拥有的属性
    property就是dom元素在js中作为对象拥有的睡醒
    对于html的标签属性来说，attribute和property是同步的，是会自动更新的，但是对于自定义的属性来说，他们是不同步的
14、let 和 const的区别是什么
    let命令不存在变量提升，如果在let前使用，会导致报错
    如果块区中存在let和const命令，就会形成封闭作用域
    不允许重复声明
    const定义的是常量，不能修改，但是如果定义的是对象，可以修改对象内部的数据
15、内存泄漏
    定义：程序中已动态分配的堆内存由于某种原因 程序未释放或无法释放引发的各种问题
    js中可能出现的内存泄漏情况：结果：变慢，崩溃，延迟大等
    js中可能出现的内存泄漏原因：
    全局变量
    dom清空时，还存在引用
    定时器未清除
    子元素存在引起的内存泄漏
16、数组（array）方法
    map:遍历数组，返回回调返回值组成的新数组
    forEach：无法break，可以用try/catch中throw new Error来停止
    filter：过滤
    some:有一项返回true，则整体为true
    every:有一项返回false，则整体返回false
    join：通过指定连接符生成字符串
    push/pop：末尾推入和弹出，改变原数组，返回推入/弹出项
    unshift/shift：头部推入和弹出，改变原数组，返回操作项
    sort(fn)/reverse：排序与反转，改变原数组
    concat:连接数组，不影响原数组，浅拷贝
    slice(start,end):返回截断后的新数组，不改变原数组
    splice(start,number,value__):返回删除数组组成的数组，value为插入项，改变原数组，
    indexOf /lastIndexOf(value,fromIndex):查找数组项，返回对应的下标
    reduce/reduceRight(fn(pre,cur),defaultPrev):两两执行，prev为上次化简2函数的return值，cur为当前值（从第二项开始）
17、说说异步编程的实现方式
    回调函数
    优点：简单，容易理解
    缺点：不利于维护，代码藕合高

    事件监听
    优点：容易理解、可以绑定多个事件，每个事件可以指定多个回调函数
    缺点：事件驱动型，流程不够清晰

    发布/订阅（观察者模式）
    类似于事件监听，但是可以通过“消息中心”，了解现在有多少发布者，有多少订阅者

    promise对象
    优点：可以利用then方法，进行链式写法，可以书写错误时的回调函数
    缺点：编写和理解，相对比较难

    Generator函数
    优点：函数体内外的数据交换，错误处理机制
    缺点：流程管理不方便

    async函数
    优点:内置执行器，更好的语义，更广的适用性，返回的是promise，结构清晰
    缺点：错误的处理机制

18、说说面向对象编程思想？
    基本思想是使用对象、类、继承、封装等基本概念来进行程序设计
    优点：
    易维护
    易扩展
    开发工作的重用性、继承性高、降低重复工作量
    缩短了开发周期
19、项目性能优化
    减少http请求数
    减少DNS查询
    使用CDN
    避免重定向
    图片懒加载
    减少DOM元素数量
    减少DOM操作
    使用外部JavaScript和CSS
    压缩JavaScript CSS 字体 图片等
    优化CSS  Sprite
    使用iconfont
    多域名分发划分内容到不同域名
    尽量减少iframe使用
    避免图片src为空
    把样式表放在link中
    把JavaScript放在页面底部
20、什么是单线程，和异步的关系
    单线程：只有一个线程，只能做一件事
    原因：避免DOM渲染的冲突
    浏览器需要渲染DOM
    JS可以修改DOM结构
    JS执行的时候，浏览器DOM渲染会暂停
    两段JS也不能同时执行（都修改DOM就冲突了）
    webworker支持多线程，但是不能访问DOM
    解决方案：异步

21、说说负载均衡？
    单台服务器共同协作，不让其中某一台或几台超额工作，发挥服务器的最大作用
    http重定向负载均衡：调度者根据策略选择服务器以302响应请求，缺点只有第一次有效果，后续操作维持在该服务器DNS负载均衡：解析域名时，访问多个ip服务器中的一个（可监控性较弱）原因--避免DOM渲染的冲突
    反向代理负载均衡：访问统一的服务器，有服务器进行调度访问实际的某个服务器，对统一的服务器要求大，性能受到服务器群的数量影响

22、作用域链
    作用域链可以理解为一组对象列表，包含 父级和自身的变量对象，因此我们便能通过作用域链访问到父级里声明的变量或函数
23、什么事原型、原型链、继承
    所有的函数都要prototype属性（原型）
    所有的对象都有__proto__属性
    在JavaScript中，每个函数都有一个原型属性prototype指向自身的原型，而由这个函数创建的对象也有一个proto属性指向这个原型，而函数的原型是一个对象，所以这个对象也会有一个proto指向自己的原型，这样逐层深入直到object对象的原型，这样就形成了原型链
24、JS垃圾回收机制是怎样的
    1、概述
    JS的垃圾回收机制是为了防止内存泄漏（已经不需要的某一块内存还一直存在着），垃圾回收机制就是不停歇的寻找这些不再使用的变量，并且释放掉它所指向的内存，在JS中，JS的执行环境会负责管理代码执行过程中使用的内存
    2、变量的生命周期
    当一个变量的生命周期结束之后，它所指向的内存就会被释放。js有两种变量，局部变量和全局变量，局部变量是在他当前的函数中产生作用，当该函数结束之后，该变量内存会被释放，全局变量的话会一直存在，直到浏览器关闭为止
    3、JS垃圾回收方式
    有两种方式：标记清除、引用计算

    标记清除：大部分浏览器使用这种垃圾回收，当变量进入执行环境（声明变量）的时候，垃圾回收器将该变量进行了标记，当该变量离开环境的时候，将其再度标记，随之进行删除

    引用计数：这种方式常常会引起内存的泄漏，主要存在于低版本的浏览器，它的机制就是跟踪某一个值的引用次数，当声明一个变量并且将一个引用类型赋值给变量的时候引用次数加1，当这个变量指向其他一个时引用次数减1，当为0时出发回收机制进行回收
25、逐层增强和优雅降级
    针对低版本浏览器进行构建页面，保证最基本的功能，然后再针对高版本浏览器进行效果，交互等改进和追加功能达到更好的用户体验

    优雅降级
    一开始就构建完整的功能，然后再针对低版本浏览器进行兼容
### Vue面试题
1、vue的优点
    轻量级
    简单易学
    低耦合
    可重用性
    独立开发
    文档齐全，且文档为中文文档
2、vue父子组件传递数据
    props
    $emit
3、v-show和v-if指令的共同点和不同点
    共同点：都是动态显示 DOM 元素
    区别点：
    v-if是动态的向DOM树内添加或者删除DOM元素
    v-show是通过设置DOM元素的display样式属性控制显隐
    v-if切换有一个局部编译/卸载的过程，切换过程中合适地销毁和重建内部的事件监听和子组件
    v-show只是简单的基于css切换
    性能消耗
    v-if有更高的切换消耗
    v-show有更高的初始渲染消耗
    使用场景
    v-if适合运营条件不大可能改变
    v-show适合频繁切换

4、如何让css只在当前组件中起作用
    scoped
5、<keep-alive></keep-alive>的作用是什么
    主要是用于需要频繁切换的组件时进行缓存，不需要重新渲染页面
6、如何获取dom
    给dom元素加ref='refname',然后通过this.$refs.refname进行获取元素
7、说出几种vue当中的指令和它的用法
    v-model
    v-on 
    v-html
    v-text
    v-once
    v-if
    v-show
8、vue-loader是什么，它的用途是什么
    vue文件的一个加载器，将template/js/style转换为js模块
    用途：js可以写es6、style样式
9、为什么用key
    给每个dom元素加上key作为唯一标识，diff算法可以正确的识别这个节点，使页面渲染更加迅速。
10、v-on可以监听多个方法吗
    可以，比如v-on="onclick,onblur"
11、$nextTick的使用
    在data()中的修改后，页面中无法获取 data修改后的数据，使用$nextTick时，当data中数据修改后，可以实时的渲染页面
12、vue组件中data为什么必须是一个函数
    因为JavaScript的特性所导致，在component中，data必须以函数的形式存在，不可以是对象。
    组件中的data写成一个函数，数据以函数返回值的形式定义，这样每次复用组件的时候，都会返回一个新的data，相当于每个组件实例都有自己私有的数据空间，他们只负责各自维护数据，不会造成混乱。而单纯的写成对象形式，就是所有组件实例共用了一个data，这样改一个全部都会修改。
13、vue在双向数据绑定是如何实现的
    vue双向数据绑定是通过数据劫持，组合，发布订阅模式的方式来实现的，也就是说数据和视图同步，数据发生变化，视图跟着变化，数据也随之发生变化
    核心：关于vue双向数据绑定，其核心是Object.defineProperty()方法
14、单页面应用和多页面应用区别及缺点
    单页面应用（SPA)，通俗的说就是指只有一个主页面的应用，浏览器一开始就加载所有的js、html、css。所有的页面内容都包含在这个主页面中。但在写的时候，还是分开写，然后再交互的时候有路由程序动态载入，单页面的页面跳转，仅刷新局部资源，多用于pc端。
    多页面应用（MPA），就是一个应用中有多个页面，页面跳转时是整页刷新
    单页面的优点：用户体验好，快，内容的改变不需要重新加载整个页面，基于这一点spa对服务器压力较小；前后端分离，页面效果会比较酷炫
    单页面的缺点：不利于seo;导航不可用，如果一定要导航需要自行实现前进、后退、初次加载时耗时多；页面复杂度提高很多
15、Vue项目中为什么要在列表组件中写key，其作用是什么
    key是给每一个vnode的唯一id，可以依靠key,更准确，更快的拿到oldvnode中对应的vnode结点
    更精确
    因为带key就不是就地复用了，在someNode函数a.key===b.key对比中可以避免就地复用的情况，所以会更加准确
    更快
    利用key的唯一性生成map对象来获取对应节点，比遍历方式更快
16、父组件和子组件生命周期钩子执行顺序是什么
    加载渲染过程
    父 beforeCreate -> 父 created ->父 beforeMount ->子 beforeCreate -> 子 created ->子 beforeMount ->
    子 mounted -> 父 mounted
    子组件更新过程
    父 beforeUpdate -> 子 beforeUpdate -> 子 updated -> 父 updated
    父组件更新过程
    父 beforeUpdate -> 父 updated 
    销毁过程
    父 beforeDestory -> 子 beforeDestory -> 子 destoryed -> 父 destoryed
17、谈一谈你对nextTick的理解
    当你修改了data的值然后马上获取这个dom元素的值，是不能获取到更新后的值，你需要使用$nextTick这个回调，让修改后的data值渲染到dom元素之后再获取，才能成功
18、vue更新数组时触发视图更新的方法
    push()
    pop()
    shift()
    unshift()
    splice()
    sort()
    reverse()
19、什么是vue生命周期，有什么作用
    每个Vue实例在被创建时都要经过一系列的初始化过程，例如，需要设置数据监听，编译模板，将实例挂载到DOM并在数据变化时更新DOM等，同时在这个过程中也会运行一些叫做生命周期钩子的函数，这给了用户在不同阶段添加自己代码的机会
20、第一次页面加载会触发哪几个钩子？
    beforeCreate、created、beforeMount、mounted
21、vue获取数据一般在哪个周期函数
    created 
    beforeMount
    mounted
22、created和mounted的区别
    created:在模板渲染成html前调用，即通常初始化某些属性值，然后再渲染成视图
    mounted:在模板渲染成html后调用，通常是初始化页面完成后，再对html的dom节点进行一些需要的操作
23、vue生命周期的理解
    总共分为8个阶段创建前/后，载入前/后，更新前/后,销毁前/后
    创建前/后：在beforeCreated阶段，vue实例的挂载$el和数据对象都是undefined,还未初始化，在created阶段，vue实例的数据对象data有了，$el还没有。
    载入前/后：在beforeMount阶段，vue实例的$el和data都初始化了，但还是挂载之前为虚拟的dom节点，data.message还未替换，在mounted阶段，vue实例挂载完成，data.message成功渲染
    更新前/后：当data变化时，会触发beforeUpdate和updated方法，
    销毁前/后：在执行destroy方法后，对data的变化不会再触发周期函数，说明此时vue实例已经解除了事件监听以及和dom的绑定，但是dom结构依然存在
24、vuex是什么，vuex有哪几种属性
    vuex是vue框架中状态管理
    有五种，state getter mutaion action modules
    state:基本数据（数据源存放地）
    getters：从基本数据派生出来的数据
    mutations：提交更改数据的方法，同步！
    actions:像一个装饰器，包裹mutations，使之可以同步
    modules:模块化Vuex
25、v-for和v-if的优先级
    v-for和v-if同时使用，有一个先后运行的优先级，v-for比v-if优先级更高，这就说明在v-for每次的循环赋值中每一次调用v-if的判断，所以不推荐v-if和v-for在一个标签中同时使用
26、vue事件中如何使用event对象
    获取事件对象，方法参数传递 $event,注意在事件中要使用$符号
    <button @click="Event($event)">事件对象</button>
27、组件传值方式有哪些
    父传子：子组件通过props['xx']来接受父组件传递的属性xx的值
    子传父：子组件通过this.$emit('fnName',value)来传递，父组件通过接受fnName事件方法来接受回调
    其他方式：通过创建一个bus,进行传值
    使用Vuex
28、vue中子组件调用父组件的方法？
    直接在子组件中通过this.$parent.event来调用父组件的方法
    在子组件里用$emit()向父组件触发一个事件，父组件监听这个事件就行了
    父组件把方法传入子组件中，在子组件里直接调用这个方法
29、vue路由声明式导航router-link跳转
    不带参数：
    注意：router-link中链接如果是'/'开始就是从根路由开始，如果开始不带'/',则从当前路由开始
    <router-link :to="{name:'home'}">
    <router-link :to="{path:'/home'}"> //name,path都行，建议用name

    带参数：
    <router-link :to="{name:'home',params:{id:1}}">
    <router-link :to="{name:'home',query:{id:1}}">
    <router-link :to="/home/:id">

    传递对象
    <router-link :to="{name:'detail',query:{item:JSON.stringify(obj)}}}"></router-link>
30、computed 和 watch的区别
    computed计算属性：依赖其他属性值，并且computed的值有缓存，只有它依赖的 属性值发生变化，下一次获取computed的值时才会重新计算computed的值。
    watch侦听器:更多的是观察的作用，无缓存性，类似于某些数据的监听回调，每当监听的数据变化时都会执行回调进行后续操作
    
    运用场景：
    当我们需要进行数值计算，并且依赖于其他数据时，应该使用computed，因为可以利用computed的缓存特性，避免每次获取值时，都要重新计算
    当我们需要在数据变化时执行或开销较大的操作时，应该使用watch，使用watch选项允许我们执行异步操作（访问一个API），限制我们执行该操作的频率，并在我们得到最终结果前，设置中间状态，这些都是计算属性无法做到的

    多个因素影响一个显示，用computed
    场景：商品订单购物车
    一个因素的变化影响多个其他因素显示，用watch
    场景：搜索列表

    computed 和 methods的区别
    computed:计算属性是基于他们的依赖进行缓存的，只有在它的相关依赖发生变化时才会重新求值，对于method，只要发生重新渲染，method调用总会执行该函数
31、如何解决数据层级结构太深的问题
    在开发业务时，经常会出现异步获取数据的情况，有时数据层次比较深，如以下代码
    span 'v-text="a.b.c.d">,可以使用vm.$set手动定义一层数据：vm.$set("demo",a.b.c.d)
32、vue常用指令
    v-model 多用于表单元素实现双向数据绑定（同angular中的ng-model)
    v-bind 动态绑定 作用：及时对页面的数据进行更改
    v-on:click 给标签绑定函数，可以缩写为@,例如绑定一个点击函数，函数必须写在methods里面
    v-for 格式：v-for="字段名 in(of) 数组json" 循环数组或json（同angular中的ng-repeat)
    v-show 显示内容（同angular 中的ng-show)
    v-hide 隐藏内容（同angular中的ng-hide)
    v-if 显示与隐藏（dom元素的删除添加 同angular中的ng-repeat)
    v-else-if 必须和v-if连用
    v-text 解析文本
    v-html 解析html标签
    v-bind:class 三种绑定方法
    对象型'{red:isred}'
    三元型'isred?"red":"blue"'
    数组型'[{red:"isred"},{blue:"isblue"}]'
    v-once进入页面时，只渲染一次，不在进行渲染
    v-cloak 防止闪烁
    v-pre 把标签内部的元素原位输出
33、$route 和 $router的区别、
    $route是"路由信息对象",包括path，params,hash,query,fullPath,matched,name等路由信息参数
    $router是"路由实例"对象包括了路由的跳转方法，钩子函数等
34、怎样理解vue的单向数据流
    数据总是从父组件传到子组件、子组件没有权利修改父组件传过来的数据，只能请求父组件对原始数据进行修改，这样会防止从子组件意外改变父组件的状态。从而导致的你的应用的数据流向难以理解。
    注意：在子组件直接用v-model绑定父组件传过来的props这样是不规范的写法，开发环境会报警告
    如果实在要改变父组件的props值，可以在data里面定义一个变量，并用prop的值初始化它，之后用$emit通知父组件去修改
35、vuex页面刷新数据丢失怎么解决
    需要做vuex数据持久化，一般使用本地储存的方案来保存数据，可以自己设计存储方案，也可以使用第三方插件
    推荐使用vuex-persist（脯肉赛特斯）插件，它是为vuex持久化储存而生的一个插件，不需要你手动存取storage，而是直接将状态保存至cookie或者localStorage中