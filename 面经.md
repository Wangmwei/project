### http状态码
-- 1 请求未成功
-- 2 请求成功
-- 3 请求被重定向
-- 4 请求错误，自身原因
-- 5 请求错误，服务器原因


### http  与 https区别
基本概念：
http超文本传输协议，是互联网上应用最为广泛的一种网络协议，
是一个客户端和服务器端请求和应答的标准，用于从www服务器传输超文本到
本地浏览器的传输协议，它可以使浏览器更加高效，使网络传输减少。
https是以安全为目标的http通道，简单讲就是http的安全版，即http下加入了ssl，层
https的安全基础是ssl，因此加密的详细内容就需要ssl
https协议的主要作用是：建立一个信息安全通道，来确保数据的传输，确保网站的真实性。
 
两者区别：
http传输的数据都是未加密的，也就是明文的，
网景公司设置了ssl协议来对http协议传输的数据进行加密处理，简单来说，
https协议是由http和ssl协议构建的可进行加密传输的身份认证的网络协议，比
http协议的安全性更高，

主要区别:
https协议需要ca证书，费用比较高，（一般功能越大的证书，费用越高）
http是超文本传输协议，信息是明文传输，https是具有安全性的ssl加密传输协议，
使用不同的连接方式，端口也不同，一般：http80端口，https 443端口
http连接很简单，是无状态的，


### tcp  udp 区别

都在传输层（运输层）
tcp 传输控制协议 udp 用户数据报协议
tcp 面向连接的，可靠的，无差错的，不丢失的，不重复的，按序到达的数据传输服务，
udp 面向无连接的，不可靠的，数据传输服务，
tcp首部较大，为20字节，支持一对一传输
udp首部不大，只有8字节，支持一对一传输，一对多传输

### http 2.0  是基于1999年发布的http1.0之后的首次更新
http2.0相比1.0而言：优点：
提升访问速度    相比1.0，请求资源所需时间更少，访问速度更快
允许多路复用    相比1.1， 多路复用允许同时通过单一的http2连接发送多重请求，响应信息
                改善了在http1.1中，浏览器客户端在同一时间，针对统一域名下的请求
                有一定数量限制（连接数量），超过限制会被阻塞
二进制分帧      http2.0会将所有的传输信息分割为更小的信息或者帧，并对他们进行 
                二进制编码
首部压缩 
服务器端推送

###  了解的状态码

100 Continue   继续：客户端应继续其请求
101 Switching Protocols 切换请求：服务器根据客户端的请求切换协议，只能切换到更高级的协议，例如：切换到http的新版本协议

200 OK 请求成功：一般用于GET与POST请求
201 Created 已创建：成功请求并创建了新的资源
202 Accepted 已接受：已经接受请求，但未处理完成
203 Non-Authoritative Information 非授权信息：请求成功，但返回的meta信息不在原始的服务器，而是一个副本
204 No Content 无内容：服务器成功处理，但为返回内容，在未更新网页的情况下，可确保浏览器继续显示当前文档
205 Reset Content 重置内容：服务器处理成功，用户终端（例如：浏览器）应重置文档视图，可通过此返回码清除浏览器的表单域
206 Partial Content 部分内容：服务器成功处理了部分GET请求

300 Multiple Choices 多种选择：请求的资源可包括多个位置，相应可返回一个资源特征与地址的列表用于用户终端（例如：浏览器）选择
301 Moved Permanently 永久移动：请求的资源已被永久的移动到新URL，返回信息会包括新的URL，浏览器会自动定向到新的URL，今后任何新的请求都会使用新的URL代替
302 Found 临时移动：与301类似，但资源只是临时被移动，客户端应继续使用原有URL
303 See Other  查看其他地址：与301类似，使用get和POST请求查看
304 Not modified 未修改：所请求的资源未修改，服务器返回此状态码时，不会返回任何资源，客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源。


400 请求无效
产生原因：前端提交数据的字段名和字段类型与后台的实体没有保持一致，前端提交到后台的数据应该是json字符串类型，但是前端没有将对象json.stringify转化为字符串
解决方法：对照字段的名称，保持一致性

401 当前请求需要用户验证
403 服务器已经得到了请求，但是拒绝执行

### 标签语义化（前端优化） 
html5新增标签语义化是指用正确的标签包含正确的内容，结构良好，便于阅读，比如:nav head footer article ···

### web安全防御（xss csrf)
xss  通过httponly属性或者secure属性解决
csrf 

### addEventListener(参数1，参数2，参数3) 参数
参数1：event
参数2:function()
参数3：useCapture ：true(捕获）、false（冒泡）

# http缓存和协商缓存
缓存分两种，http缓存、协商缓存、划分依据是：根据响应的header内容来决定
http缓存：也叫强缓存，从缓存中获取资源，状态码为200（from cache）不需要发送请求到服务器，直接从缓存中取
协商缓存：也是从缓存中获取资源，状态码为304(not modified) 要发送请求给服务器，通过服务器来告知缓存是否可用

# 什么时候用http缓存，什么时候用协商缓存？
因为服务器上的资源不是一直固定不变的，大多数情况下它会更新，这个时候如果我们还访问本地缓存，那么对用户来说，那就相当于资源没有更新，用户看到的还是旧的资源；
所以我们希望服务器上的资源更新了浏览器就请求新的资源，没有更新就使用本地的缓存，以最大程度的减少因网络请求而产生的资源浪费

# 前端优化
降低请求量：合并资源，减少http请求数，minify/gzip压缩，webp, lazyLoad.
加快请求速度：预解析DNS,减少域名数，并行加载，CDN分发
缓存：http协议缓存请求，离线缓存minifest，离线数据缓存localStorage
渲染：js/css优化，加载顺序，服务端渲染，



#  GET POST
get参数通过url传递，post放在request body中
get请求在url中传递的参数是有长度限制的，而Post没有
get比post更不安全，因为参数直接暴露在url中，所以不能用来传递敏感信息
get请求只能进行url编码，而post支持多种编码方式
get请求会浏览器主动cache,而post支持多种编码方式
get请求参数会被完整保留在浏览器历史记录里，而post中的参数不会被保留
get和post本质上就是TCP链接，并无差别，但是由于http的规定和浏览器、服务器的限制，导致他们在应用过程中体现出一些不同
get产生一个Tcp数据包；post产生两个TCP数据包
# cookie session localstorage sessionstorage

# 浏览器输入网址到页面渲染全过程
DNS解析--tcp连接--发送http请求--服务器接收请求并返回http报文--浏览器解析报文--渲染页面--连接结束

# POST 和 GET区别
GET--从指定的资源请求数据
POST--向指定的资源提交要被处理的数据
GET:从不同的浏览器和服务器不同，一般限制在2-8K之间，更加常见的是1K以内。
GET和POST的底层也是TCP/IP，GET/POST都是TCP连接
GET产生一个TCP数据报；POST产生两个TCP数据包；
对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）；
而对于POST，浏览器先发送header,服务器响应100continue，浏览器再发送data,服务器响应200ok

# link 和 import标签的区别
link属于html标签，而@import是css提供的
页面被加载时，link会同时被加载，而@import引用的css会等到页面加载结束后加载。
link是html标签，因此没有兼容性，而@import只有IE5以上才能识别
link方式样式的权重高于@import的


# transition  和 animation 的区别
animation 和 transition 大部分属性是相同的，他们都是随着时间改变元素的属性值，他们的主要区别是transition需要触发一个事件才能改变属性，而animation 不需要触发任何事件的情况下才会随时间改变属性值，并且transition为2帧，从from 到to ，而animation可以一帧一帧的
# Flex布局
给容器定义flex布局，也可以给行内元素定义flex布局
flex有6个属性：
flex-direction
flex-wrap
flex-flow
justify-content
align-items
align-content
容易有两条线，主轴和交叉轴
主轴main axis 
交叉轴 cross axis
内部项目横向长度为main size
内部项目纵向长度为cross size

# BFC 块级格式化上下文，用于清除浮动，防止margin重叠等
直译成：块级格式化上下文，是一个独立的渲染区域，并且有一定的布局规则。
BFC区域不会与float box重叠
BFC是页面上的一个独立容器，子元素不会影响到外面
计算BFC的高度时，浮动元素也会参与计算
哪些元素会生成BFC：
根元素；
float不为none的元素
position为fixed和absolute的元素
display为inline-block，table-cell,table-caption,flex,inline-flex的元素
overflow部位visible的元素

资料显示BFC:
BFC(Block Formatting context)直译为“块级格式化上下文”，它是一个独立的渲染区域，只有Block-level box参与，它规定了内部的Block-level Box如何布局，并且与这个区域外部毫不相干。
# BFC布局规则
内部的Box会在垂直方向，一个接一个地放置
Box垂直方向的距离由margin决定，属于同一个BFC的两个相邻Box的margin会发生重叠
在BFC中，每一个盒子的左外边缘（margin-left)会触碰到容器的左边缘（border0left)（对于从右到左的格式来说，则触碰到右边缘），即使存在浮动也是如此。
BFC的区域不会与float Box重叠
BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素，反之也如此。
计算BFC的高度时，浮动元素也参与计算

### BFC作用：
①：可以解决同一个BFC下产生的margin重叠问题
②：可以解决由浮动引起的高度塌陷问题
③：可以形成两列、三列自适应布局（原理：一个盒子给宽高，另一个盒子不给宽度或高度，形成自适应效果）

### 事件委托：
简介：事件委托是指 不再事件的发生地（直接DOM）上设置监听函数，而是在其父元素上设置监听函数，通过事件冒泡，父元素可以监听到子元素上事件的触发，通过判断事件发生元素DOM的类型，来做出不同的响应。
举例：最经典的就是ul和li标签的时间监听，比如我们在添加事件的时候，采用事件委托机制，不会在li标签上直接添加，而是在ul父元素上添加，
好处：比较合适动态元素的绑定，新添加的子元素也会有监听函数，也可以有时间触发机制。

### 图片的懒加载和预加载
预加载：提前加载图片，当用户需要查看时可直接从本地缓存中渲染。
懒加载：懒加载的主要目的是作为服务器前端的优化，减少请求数或延迟请求数

两种技术的本质：两者的行为是相反的，一个是提前加载，一个是迟缓甚至不加载，懒加载对服务器前端有一定的缓解压力作用，预加载则会增加服务器前端压力

### display:table 和 本身table的区别
display:table和本身table是相对应的，区别在于，display:table的css声明能够让一个html元素和它的子节点像table一样，使用基于表格的css布局，是我们能够轻松定义一个单元格的边界，背景等样式，而不会产生因为使用了table那样的制表标签导致的语义化问题。

之所以现在逐渐淘汰了table系表格元素，是因为用div+css编写的文件比用table编写出来的文件小，而且table必须在页面完全加载后才显示，div则是逐行显示，table的嵌套性太多，没有div简洁

### mouseover和mouseenter的区别
mouseover：当鼠标移入元素或其子元素都会触发事件，所以有一个重复触发，冒泡的过程，对应的移除事件时mouseout
mouseenter:当鼠标移除元素本身(不包括元素的子元素)会触发事件，也就是不会冒泡，对应的移除事件是mouseleave

### JS的new操作符做了哪些事情
new操作符新建了一个空对象，这个对象原型指向构造函数的prototype，执行构造函数后返回这个对象。

### 改变函数内部this指针的指向函数（bind,apply,call的区别）
通过apply和call改变函数的this指向，他们两个函数的第一个参数都是一样的，表示要改变指向的那个对象，第二个参数，apply是数组，而call则是arg1,arg2,····这种形式，通过bind改变this作用域会返回一个新的函数，这个函数不会马上执行

### JS的各种位置，比如clientHeight, scrolHeight,offsetHeight 以及scrollTop,offsetTop,clientTop的区别
clientHeight:表示的是可视区域的高度，不包括border和滚动条
offsetHeight:表示的是可视区域的高度，包括border和滚动条
scrollHeight:表示了所有区域的高度，包含了因为滚动而隐藏的部分

clientTop:表示边框border的厚度，在未指定的情况下一般为0
scrolTop:滚动后被隐藏的高度，获取对象相当于由offsetParent属性指定的父坐标（css定位的元素或body元素）距离顶端的高度


### JS拖拽功能的实现
首先是三个事件，分别是mousedown，mousemove，mouseup
当鼠标点击按下的时候，需要一个tag标识此时已经按下，可以执行mouseover里面的具体方法。

clientX,clientY标识的是鼠标的坐标，分别标识横坐标和纵坐标，并且我们用offsetX和offsetY来表示元素的初始坐标，移动的距离应该是：clientX-offsetX / clientY-offsetY

### 异步加载JS的方法：
defer:只支持IE,如果您的脚本不会改变文档的内容，可将defer属性加入到script标签中，以便加快处理文档的速度，因为浏览器知道它将能够安全地读取文档的剩余部分而不用执行脚本，它将推迟对脚本的解释，直到文档已经显示给用户为止。
async:html5属性仅适用于外部脚本，并且如果在IE中，同时存在defer和async,那么defer的优先级比较高，脚本将在页面完成时执行。
创建script标签，插入到DOM中

### JS的垃圾回收机制
必要性：由于字符串，对象和数组没有固定大小，所以当他们的大小已知时，才能对他们进行动态的存储分配。JavaScript程序每次创建字符串，数组和对象时，解释器都必须分配内存来存储那个实体。只要像这样动态地分配了内存，最终都要释放这些内存以便他们能够被再用，否则，JavaScript的解释器将会消耗完系统中所有可用的内存，造成系统崩溃、
这段话解释了为什么系统需要垃圾回收，js不想c/c++，它有自己的一套垃圾回收机制，javascript的解释器可以检测到何时程序不再使用一个对象了，当他确定了一个对象是无用的时候，他就知道不再需要这个对象，可以把它所占用的内存释放掉了，例如：


垃圾回收的方法：标记清除，计数引用
标记清除：
这是最常见的垃圾回收方式，当变量进入环境时，就标记这个变量为“进入环境”，从逻辑上讲，永远不能释放进入环境的变量所占的内存，永远不能释放进入环境变量所占用的内存，只要执行流程进入相应的环境，就可能用到他们。当离开环境时，就标记为离开环境。垃圾回收器在运行的时候会给存储在内存中的变量都加上标记（所有都加），然后去掉环境变量中的变量，以及被环境变量中的变量所引用的变量（条件性去除标记），删除所有被标记的变量，删除的变量无法在环境变量中被访问所以会被删除，最后垃圾回收器完成了内存的清除工作，并回收他们所占用的内存。

### 前端模块化
前端模块化就是复杂的文件变成一个一个独立的模块，比如JS文件等等，分成独立的模块有利于重用和维护，即复用性，版本迭代。这样会引来模块之间相互依赖的问题，所以有了commonJS规范，AMD,CMD规范等等，以及用于JS打包（编译等处理）的工具webpack

说一下CommonJS,AMD和CMD
一个模块是能实现特定功能的文件，有了模块就可以方便的使用别人的代码，想要什么功能就加载什么模块。
CommonJS:开始于服务器端的模块化，同步定义的模块化，每个模块都是一个单独的作用域，模块输出，modules,exports,m模块加载require()引入模块。
AMD:中文名异步模块定义的意思
requireJS实现了AMD规范，主要解决两个问题：
1，多个文件有依赖关系，被依赖的文件需要早于依赖它的文件加载到浏览器
2，加载的时候浏览器会停止页面渲染，加载文件越多，页面失去响应的时间越长。
语法：requireJS定义了一个函数define,它是全局变量，用来定义模块。

总结AMD规范：require()函数在加载依赖函数的时候是异步加载的，这样浏览器不会失去响应，它指定的回调函数，只有前面的模块加载成功，才会去执行。
因为网页在加载JS的时候会停止渲染，因此我们可以通过异步的方式去加载JS,而如果需要依赖某些，也就是异步去依赖，依赖后再执行某些方法。


### 实现深拷贝：
function deepClone(source){
    const targetobj=source.constructor===Array?[]:{};
    for(let key in source){
        if(source.hasOwnPropotype(key)){
            if(source[key]&&typeof source ==='object'){
                targetobj[key]=deepclone(source[key]);
            }else{
                targetobj[key]=source[key];
            }
        }
    }
    return targetobj;
}

### 在地址栏中输入一个url，到这个页面呈现出来，中间会发生什么？

输入url后，首先需要找到这个url域名的服务器，为了寻找这个ip，浏览器首先会寻找缓存，查看缓存中是否有记录，缓存的查找顺序为：浏览器缓存》系统缓存》路由器缓存，缓存中没有则查找系统的hosts文件是否有记录，如果没有则查询DNS服务器，得到服务器的ip地址，根据这个ip以及相应的端口号，构造一个http请求，这个请求报文会包括这次请求的信息，主要是请求方法，请求说明，和请求附带的数据，并将这哥http请求封装在一个tcp包中，这个tcp包会依次经过传输层，网络层，数据链路层，物理层到达服务器，服务器解析这个请求来做出响应，返回相应的html给浏览器，因为html是属性结构，浏览器会根据这个html来构建DOM树，在DOM树的构建过程中如果遇到JS脚本和外部JS连接，则会停止构建DOM来执行和下载相应的代码，这会造成阻塞，这就是为什么推荐JS代码应该放在HTML后面的原因，之后根据外部样式，内部样式，内联样式，构建一个css对象模型树CSSOM树，构建完成之后和DOM树合并为渲染树，这里主要做的排除非视觉结点，比如script，meta标签和display:none 的节点，之后进行布局，布局主要是确定各个元素的位置和尺寸，之后是渲染页面，因为html文件中会含有图片，视频，音频，等资源，在解析DOM的过程中，遇到这些都会进行并行下载，浏览器对每个域的并行性下载数量有一定的限制，一般是4--6个，当然在这些所有的请求中我们还需要关注的就是缓存，缓存一般通过Cache-Control，Last-Modify,Exs等首部字段耦控制，Cache-Control和Expires的区别在于Cache-Control用的是相对时间，而Expires使用的是基于服务器端的绝对时间，因为存在时差问题，一般采用Cache-Control，在请求这些有设置缓存的数据时，会先查看是否过期，如果没有过期，则直接使用本地缓存，过期则请求，并在服务器校验文件是否修改，如果上一次响应设置了ETag值会在请求的时候作为if-None-Match值交给服务器校验，如果一致，继续校验Last-Mofidied，没有设置ETag,则直接验证Last-Modified，再决定是否返回304


### get 与 post请求在缓存方面的区别
get类似于是查找的过程,用户获取数据，可以不用每次都与数据库连接，所以可以使用缓存
post不同，post做的一般是修改和删除的工作，所以必须与数据库交互，所以不能使用缓存，因此get请求适合于请求缓存

## 一句话概括闭包
闭包就是能够读取其他函数内部变量的函数，或者子函数在外调用，子函数所在的父函数的作用域不会被释放

### 类的创建和继承
 es5: new 一个function,在这个function 的prototype里面增加属性和方法
 
 function Animal(name){
	 this.name=name||'Animal';
	 this.sleep=function(){
		 console.log(this.name+'正在睡觉');
	 }
 }
 Animal.prototype.eat=function(food){
	 console.log(this.name+'正在吃'+food);
 }
 function Cat(){
	 Cat.prototype=new Animal();
	 Cat.prototype.name='cat';
	 var cat=new Cat();
	 
 }
 function Cat(name){
	 Animal.call(this);
	 this.name=name||'Tom';
 }
#### 原型链继承
特点：基于原型链，既是父类的实例，也是子类的实例
缺点：无法实现多继承
#### 构造继承
特点：可以实现多继承
缺点：只能继承父类实例的属性和方法，不能继承原型上的属性和方法
#### 实例继承和拷贝继承
实例继承：为父类实例添加新特性，作为子类实例返回
拷贝继承：拷贝父类元素上的属性和方法

### 解决异步回调地狱
promise generator async/await

### 前端中的事件流
HTML中JavaScript交互是通过事件驱动来实现的，例如鼠标点击事件，onclick,
页面的滚动事件onscroll等，可以向文档或者文档中的元素添加事件侦听器来预定事件
事件流：
事件捕获阶段
处于目标阶段
事件冒泡阶段
addEventListener:第三个参数，布尔值，true:捕获阶段、false:冒泡阶段
IE只支持事件冒泡

### 如何让事件先冒泡后捕获
在DOM标准事件模型中，是先捕获后冒泡，但是如果要实现先冒泡后捕获的效果，
对于同一个事件，监听捕获和冒泡，分别对应相应的处理函数，监听到捕获事件，先暂缓执行，
知道冒泡事件被捕获后再执行捕获事件

### 事件委托
不在事件的发生源上（直接DOM)上设置监听函数，而是在其父元素上设置监听事件，
通过事件冒泡，父元素可以监听到子元素上事件的触发，通过判断事件发生元素DOm的
类型，来做出不同的响应
举例：ul>li标签的事件监听，比如在添加事件时候，采用事件委托机制，不会在li
标签上直接添加，而是在ul父元素上添加。
好处：比较适合动态元素的绑定，新添加的子元素也会有监听函数，也可以有事件触发机制

### 图片从懒加载和预加载
预加载：提前加载图片，当用户需要查看时可直接从本地缓存中渲染
懒加载：懒加载的主要目的是作为服务器前端的优化，减少请求数和延迟请求数

两种技术的本质：两者的行为是相反的，一个是提前加载，一个是迟缓甚至不加载。
懒加载对服务器端有一定的缓解压力的作用，预加载则会增加服务器前端压力

### mouseover  和   mouseenter  的区别
mouseover:当鼠标移入元素或其子元素都会触发事件，所以有一个重复触发，
冒泡的过程，对应的移除事件是mouseout
mouseenter:当鼠标移入元素本身（不包含元素的子元素）会触发事件，也就是不会冒泡，
对应的移除事件是mouseleave

### JS的new操作符做了哪些事情
new操作符新建了一个空对象，这个对象原型指向构造函数的prototype，执行构造函数
后返回这个对象

### this的指向（bind,apply,call的区别）
通过apply和call改变函数的this指向，他们两个函数的第一个参数都是一样的，
表示要改变指向的那个对象，第二个参数有所区别，apply是数组，而call则是arg1,arg2··
这种形式，通过bind改变this作用域会返回一个新的函数，这个函数不会马上执行

### JS拖拽功能的实现
首先是三个事件:mousedown  mousemove  mouseup 
当鼠标点击按下的时候，需要一个tag标识此时已经按下，可以执行mousemove里面的具体方法
clientX，clientY标识的是鼠标的坐标，分别标识横坐标和纵坐标，并且我们用
offsetX和offsetY来表示元素的初始坐标，移动的举例应该是：
鼠标移动时候的坐标-鼠标按下去时候的坐标。
也就是说定位信息为：
鼠标移动时候的坐标=鼠标按下去时候的坐标+元素初始情况下的offsetLeft

### 异步加载JS的方法 defer  async

defer:只支持IE，如果你的脚本不会改变文档的内容，可将defer属性加入script
标签,以便加快处理文档的速度，因为浏览器知道它将能够安全的读取文档的剩余部分
而不用执行脚本，它将推迟对脚本的解释，直到文档已经显示给用户为止
async:html5属性，仅用于外部脚本，并且如果在IE中，同时存在defer和async，
那么defer的优先级比较高，脚本将在页面完成时执行，创建script标签，插入DOM中

### Ajax 解决浏览器缓存问题
在ajax发送请求前加上：anyAjaxObj.setRequestHeader("If-Modified-Since","0");
在ajax发送请求前加上：anyAjaxObj.setRequestHeader("Cache-Control","no-cache");
在url后面加上一个随机数："fresh="+Math.random();
在url后面加上时间戳："nowtime="+new Date().getTime()
如果是使用JQuery，直接：$.ajaxSetup({cache:false});
这样页面的所哟ajax都会执行这条语句，就是不需要保存缓存记录

### JS中的垃圾回收机制
必要性：由于字符串，数组，对象都没有固定大小，所以当他们的大小已知时，才能对他们进行
动态的存储分配，JS程序中，每次创建字符串，数组或对象时，解释器都必须分配内存
来存储那个实体，只要像这样动态的分配了内存，最终都要释放这些内存以便他们能够
复用，否则，js的解释器将会消耗完系统中所有可用的内存，造成系统崩溃，
这段话解释了为什么系统需要垃圾回收、
JS的解释器可以检测都何时程序不再使用一个对象了，当他确定了一个对象是无用的，
他就知道不再需要这个对象，可以把它所用的内存释放掉，

垃圾回收的方法：标记清除，计数引用
标记清除：
这是最常见的垃圾回收方式，当变量进入环境时，就标记这个变量为“进入环境”，从逻辑上，
永远不能释放进入环境的变量所占的内存，只要执行流程进入相应的环境，就可能用到
他们，当离开环境时，就标记为离开环境，垃圾回收器在执行的时候会给存储在内存中的变量
都加上标记，然后去除环境变量中的变量，以及被环境变量中的变量所引用的变量，
条件性去除标记，删除所有被标记的变量，删除的变量无法在环境变量中被访问，
所以会被删除，最后垃圾回收器，完成了内存的清除工作，并回收他们所占用的内存。

### AMD中文名：异步模块定义 
requireJS实现了AMD规范，主要解决两个问题：
①多个文件有依赖关系，被依赖的文件需要早于依赖它的文件加载到浏览器
②加载的时候浏览器会停止页面渲染，加载文件越多，页面失去响应的时间越长，

总结AMD规范：require()函数在加载依赖函数的时候是异步加载，这样浏览器不会
失去响应，它指定的回调函数，只有前面的模块加载成功，才会去执行
因为网页在加载JS的时候会停止渲染，因此，我们可以通过异步的方式去加载JS，而
如果需要依赖某些，也就是异步去依赖，依赖完后再执行某些方法


### 手写一个深拷贝
最优深拷贝
function deepclond(source){
	const targetobj=source.constructor===Array?[]:{};
	for(let keys in source){
		if(source.hasOwnPrototype(keys)){
			if(source[keys]&&typeof source[keys]==='object'){
				targetobj[keys]=deepclone(source[keys]);
			}else{
				targetobj[keys]=source[keys];
			}	
		}
	}
	return targetobj;
}
用属性实现深拷贝
let nowList=JSON.parse(JSON.stringify(list));
这种方式只能实现80%的深拷贝
理由是：剩下的20%无法拷贝函数function 
因为它的原理是    先将原引用数据类型  先转为字符串，再转回，
当对象中含有方法function时，通过该方法转换时，function性质会改变；

### JS监听对象属性的改变
假设有有个user对象
在ES5中，用Object.defineProperty来实现对已有属性的监听
Object.defineProperty(user,'name'){
	set:function(key,value){
		
	};
}
缺点:如果id不再user对象中，则不能监听id的变化
在ES6中，用Proxy来实现
var user =new Proxy({},{
	set:function(target,key,value,receiver){
		
	}
})
这样即使有属性在user中不存在，通过user，id来定义也同样可以监听这个属性的变化

### 如何实现一个私有变量，用getName方法可以访问，不能直接访问
通过defineProperty来实现
obj={
	name:wmw,
	getName:function(){
		return this.name
	}
}
object.defineProperty(obj,"name",{
	
})

通过函数的创建形式
function product(){
	var name="wmw";
	this.getName=function(){
		return name;
	}
}
var obj=new product();


### == 与 === 以及object.is的区别
==
主要存在：强制转换成number,null==undefined
""==0  //true
"0"==0  //true
""!="0"  //true
123=="123" //true
null==undefined  //true
 
 Object.is
 主要区别就是+0！=-0   而NaN==NaN
 
 
 ### 实现一个完美符合Promise/A+规范的promise v1.0版本
function myPromise(constructor){
	let self=this;
	self.status="pending";  //定义状态改变前的初始状态
	self.value=undefined;	//定义状态为resolve的时候的状态
	self.reason=undefined;	//定义状态为rejected的时候的状态
	function resolve(value){
		//两个==="pending",保证了状态的改变时不可逆的
		if(self.status==="pending"){	
			self.value=value;
			self.status="resolved";
		}
	}
	function reject(reason){
		//两个==="pending",保证了状态的改变时不可逆的
		if(self.status==="pending"){
			self.reason=reason;
			self.status="rejected";
		}
	}
	//捕获构造异常
	try{
		constructor(resolve,reject);
	}catch(e){
		reject(e);
	}
}
//同时，需要在myPromise的原型上定义链式调用的then方法
myPromise.prototype.then=function(onFullfilled,onRejected){
	let self=this;
	switch(self.status){
		case "resolved":
		onFullfilled(self.value);
		break;
		case "rejected":
		onRejected(self.reason);
		break;
		defult:
	}
}
### 输入url  到页面渲染，呈现的完整过程
输入url后，首先需要找到这个url域名的服务器ip，为了寻找这个ip，浏览器首先
会寻找缓存，查看缓存中是否有记录，缓存的查找记录为：浏览器缓存》系统缓存》路由器缓存
缓存中没有则查看系统的hosts文件中是否有记录，如果没有则查询DNS服务器，
得到服务器的ip地址后，浏览器根据这个ip以及相应的端口号，构造一个http请求，这个请求会包括
这次请求的信息，主要是请求方法，请求说明和请求附带的数据，并将这个http请求封装在一个tcp
包中，这个tcp包会依次经过传输层，网络层，数据链路层，物理层，到达服务器，服务器解析这个
请求来做出响应，返回相应的html给浏览器，因为html是一个树形结构，浏览器会根据这个html来构建dom树
在dom树的构建过程中，如果遇到js脚本和外部js连接，则会停止构建dom来执行和下载相应的代码，这回
造成阻塞，这就是为什么推荐js代码应该放在html代码的后面，之后根据外部样式，内部样式，内联样式
构建一个CSSOM样式结构体，对象模型树，构建完成后和DOM树合并为渲染树render tree,这里主要
做的是排除非视觉结点，比如script meta diaplay:none   之后进行布局，布局主要是确定各个元素
的位置和尺寸，这是reflow  然后确定各个元素的颜色和字体的大小等等，这是重绘，repain
因为html文件中会有图片，视频，音频等资源，在解析DOM树的过程中，遇到这些都会进行并行下载，浏览器对每个域的并行下载数量有一定的限制，
一般是4-6个，当然在这些所有的请求中我们还需要关注的就是缓存，缓存一般通过Cache-Control，Last-Modified,Expires等首部字段控制
Cache-Contro;和Expire的区别在于Cache-Control使用相对时间，Expires使用的是基于服务器的绝对时间，因为
存在时差问题，一般用Cache-Control，在请求这些有设置了缓存的数据时，会先查看是否过期，如果没有过期则直接使用本地缓存
过期，则重新请求，并在服务器校验文件是否修改，如果上一次响应设置了ETag值会在这次请求的时候作为if-None-Mathc的值作为服务器校验
如果一致，继续检验last-modified，如果没有设置ETag,则直接验证last-modified
再决定是否返回304
### 有一个游戏叫做Flappy Bird,就是一只小鸟在飞，前面是无尽的沙漠，上下不断有钢管生成，你要躲避钢管，然后小明在玩这个游戏时候老师卡顿甚至崩溃，说出原因（3--5）个，以及解决办法（3--5个）；
原因可能是：
1，内存溢出问题
2，资源过大问题
3，资源加载问题
4，canvas绘制频率问题
解决办法：
1，针对内存溢出问题，可以在钢管离开可视区域之后让垃圾收集器回收钢管，因为不断生成的钢管不及时清理容易导致内存溢出游戏崩溃
2，针对资源过大问题，我们应该选择图片文件大小更小的图片格式，比如使用webp,png格式的图片，因为绘制图片需要较大计算量
3，针对资源加载问题，我们应该在可视区域之前就预加载好资源，如果在可视区域生成钢管的话，用户的体验就认为钢管是卡顿后才生成的，不流畅。
4，针对canvas绘制频率问题，我们应该需要知道大部分显示器刷新频率为60/s，因此游戏的每一帧绘制间隔需要小于1000/60=16.7ms,才能让用户觉得不卡顿。
注意因为是单机游戏，所以回答与网络无关

### 什么是按需加载

当用户触发了动作时才加载对应的功能，触发的动作，是要看具体的业务场景而言，包括但不限于以下几种情况：鼠标点击，输入文字，拉动滚动条，鼠标移动，窗口大小更改等，加载的文件，可以是JS，图片，css，html



### 什么是virtual dom

用JavaScript对象结构表示DOM树的结构，然后用这个树构建一个真正的DOM树，插到文档当中，当状态更改时，重新构造一棵新的对象树，然后用新的树和旧的树进行比较，记录两棵树差异，把记录的差异应用到所构建的真正的DOM树上，视图就更新了，Virtual DOM的本质上就是在JS和DOM之间做了一个缓存


### webpack用来干什么
webpack是一个现代JavaScript应用程序的静态模块打包器（module bundle）.当webpack处理应用程序时，它会递归的构建一个依赖关系图（dependency graph）,其中包括应用程序需要的每个模块，然后将所有这些模块打包成一个或多个bundle

### ant-design优点和缺点
优点：组件非常全面，样式效果也都不错
缺点：框架自定义程度低，默认UI风格修改困难

### 介绍一下Promise ,及其底层如何实现，
### 先写一个基于promise A+的promise v1.0版本
function myPromise(constructor){
	let self=this;
	self.status='pending';
	self.value=undefined;
	self.reason=undefined;
	function resolve(value){
		if(self.status==='pending'){
			self.value=value;
			self.status='resolved';
		}
	}
	function reject(reason){
		if(self.status==='pending'){
			self.reason=reason;
			self.status='rejected';
		}
	}
	try{
		constructor(resolved,rejected);
	}catch(e){
		reject(e);
	}
}
myPromise.prototype.then=function(onFulfilled,onRejected){
	let self=this;
	switch(self.stauts){
		case "resolved":
		onFulfilled(self.value);
		break;
		case "rejected":
		onRejected(self.reason);
		break;
		default:
	}
}
let p=new myPromise(function(resolve,reject){resolve(444)});
p.then(function(x){console.log(x)});

介绍：
Promise是一个对象，保存着未来将要结束的时间，它有两个特性：
1，对象的状态不受外部影响，Promise对象代表一个异步操作，有三种状态，pending进行中，fullfilled已成功，rejected已失败，只有异步操作的结果，才可以决定当前是哪一种状态，任何其他操作都无法改变这个状态，这也就是promise名字的由来
2，一旦状态改变，就不会再变，固态化，promise对象状态改变只有两种可能，从pending改到fullfilled,或者从pending改到rejected，只要这两种情况发生，状态就凝固了，不会在改变，这个时候就称为定性resolved，

### JS原型链，原型链的顶端是什么？Object的原型是什么？Object的原型的原型是什么？在数组原型链上实现删除数组重复数据的方法？
首先，明白原型，在ES6之前，JS没有类和继承这个概念，JS是通过原型来实现继承的，在JS中一个构造函数默认带有一个prototype属性，这个的属性值是一个对象，同时这个prototype对象自带有一个constructor属性，这个属性指向这个构造函数，同时每一个实例都会有一个_proto_属性指向这个prototype对象，我们可以把这个叫做隐式原型，我们在使用一个实例的方法的时候，会先检查这个实例中是否有这个方法，没有的话就会检查这个prototype对象是否有这个方法，
基于这个规则，如果让原型对象指向另一个类型的实例，即constructor.prototype=instance2，这时候如果试图引用constructor构造的实例instancel的某个属性pl,首先会在instance1内部属性中找一遍，接着会在instance1._proto_（constructor.prototype)即是instance2中寻找p1，搜寻轨迹：instance1->instance2->constructor2.prototype---->Object.prototype，这就是原型链，原型链顶端是Object.prototype
补充学习：
每个函数都有一个prototype属性，这个属性指向了一个对象，这个对象正是调用该函数而创建的实例的原型，那么什么是原型呢，可以这样理解，每一个JavaScript对象在创建的时候就会预制管理另一个对象，这个对象就是我们说的原型，每一个对象都会从原型继承属性

### 什么是JS的闭包？有什么作用？用闭包写个单例模式
MDN对闭包的定义是：闭包是指哪些能够访问自由变量的函数，自由变量是指在函数中使用的，但既不是函数参数又不是函数的局部变量的参数，由此可以看出，闭包=函数+函数能够访问的自由变量，所以从技术的角度看，所有JS函数都是闭包，但是这是理论上的闭包，还有一个实践角度上的闭包，从实践角度上看，只有满足1：即使创建它的上下文已经销毁，它仍然存在2：在代码中引入了自由变量，才称为闭包
闭包的应用：
1：模仿块级作用域
2：保存外部函数的变量
3：封装私有变量
单例模式：
var Singleton=(function(){
	var instance;
	var CreateSingleton=function(name){
		this.name=name;
		if(instance){
			return instance;
		}
		打印实例名字
		this.getName();
		return instance=this;
	}
})

### 事件委托以及冒泡原理
事件委托就是利用事件冒泡阶段的运行机制来实现的，就是把一个元素响应事件的函数委托到另一个元素，一般是把一组元素的事件委托到他的父元素上，委托的优点是：
减少内存消耗，节约效率
动态绑定事件
事件冒泡：就是元素自身的事件被触发后，如果父元素有相同的时间，如onclick事件，那么元素本身的触发状态就会传递，也就是冒泡到父元素，父元素的相同事件也会一级一级根据嵌套关系向外触发，知道document/window，冒泡过程结束


### JS中startwith和indexof两种方法的区别
JS中startwith函数，其参数有3个，stringobj：要搜索的字符串对象，str：搜索的字符串，position:可选，从哪个位置开始搜索，如果以position开始的字符串以搜索字符串开头，则返回true，否则返回false；
indexof函数：indexof函数可返回某个指定字符串在字符串中首次出现的位置。


### JS字符串转数字的方法
通过函数parseInt()，可解析一个字符串，并返回一个整数，语法为parseInt(string,radix);
string:被解析的字符串
radix:表示要解析的数字的基数，默认是十进制，如果radix<2或>36,则返回NaN

### let const var 
提起这三个最明显的区别是var声明的变量是全局或者整个函数块的，而let,const声明的变量是块级的变量，var声明的变量存在变量提升，let，const不存在，let声明的变量允许重新赋值，const不允许

### 有了解过事件模型吗，DOM 0级和DOM 2级有什么区别，DOM的分级是什么？
JS 中DOM 事件流存在如下三个阶段：
事件捕获阶段
处于目标阶段
事件冒泡阶段
JS中DOM标准事件流的触发的先后顺序为：先捕获再冒泡，点击DOM结点时，事件传播顺序：事件捕获阶段，从上往下传播，然后到达事件目标节点，最后是冒泡阶段，从下往上传播
DOM节点添加事件监听方法addEventListener,中参数capture可以指定该监听是添加在事件捕获阶段还是事件冒泡阶段，为false是事件冒泡，为true是事件捕获，并非所有的事件都支持冒泡，比如focus，blur等等，我们可以通过event.bubbles来判断
事件模型有三个常用方法：
event.stopPropagation:阻止捕获和冒泡阶段中，当前事件的进一步传播
event.stopImmediatePropagetion:阻止调用相同事件的其他监听器
event.preventDefault：取消该事件（假如事件是可取消的）而不停止事件的进一步传播，
event.target：指向触发事件的元素，在事件冒泡过程中这个值不变
event.currentTarget=this：事件绑定的当前元素，只有被点击时目标元素的target才会等于currentTarget
最后，对于执行顺序的问题，如果DOM节点同时绑定了两个事件监听函数，一个用于捕获，一个用于冒泡，那么两个事件的执行顺序真的是先捕获再冒泡的吗？答案是否定的，绑定在被点击元素的事件是按照代码添加顺序执行的，其他函数是先捕获再冒泡。

### setTimeout(fn，100),100毫秒是如何权衡的
setTimeout()函数只是将事件插入了任务列表，必须等到当前代码执行完，主线程才会去执行它指定的回调函数，有可能要等很久，所以没有办法保证回调函数一定会在setTimeout指定的时间内执行，100毫秒是插入队列的时间+等待的时间



















