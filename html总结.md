1.**块级元素和行内元素的特点以及目前标准**

以前某些元素在显示时会独占一行（块级元素），而某些元素不会（行级元素）到了html5，已经弃用这种说法，原因：根据w3c官方，元素代表的是什么含义，跟语义无关

2.**<image>标签上title属性与alt属性区别？**

alt属性是为了给那些不能看到你文档中图像的浏览者提供文字说明。且长度必须少于100个英文字符或者用户必须保证替换文字尽可能的短。

这包括那些使用本来就不支持图像显示或者图像显示被关闭的浏览器的用户，视觉障碍的用户和使用屏幕阅读器的用户等。

title属性为设置该属性的元素提供建议性的信息。使用title属性提供非本质的额外信息。

3.**标签语义化的理解？**

去掉或者丢失样式的时候能够让页面呈现出清晰的结构，

有利于SEO（搜索引擎优化）：和搜索引擎建立良好沟通，有利于爬虫抓取更多的有效信息：爬虫依赖于标签来确定上下文和各个关键字的权重；

方便其他设备解析，以意义的方式来渲染网页；

便于团队开发和维护，语义化更具有可读性，遵循w3c标准的团队都遵循这个标准，可以减少差异化。

①用正确的标签做正确的事情

②html语义化让页面的内容结构化，结构更清晰，便于对浏览器、搜索引擎解析；即使在没有样式css情况下也以一种文档格式显示，并且是容易阅读的

③搜索引擎的爬虫也依赖于HTML标记来确定上下文和各个关键字的权重，利于SEO

④使阅读源代码的人对网站更容易将网站分块，便于阅读维护理解。

4.**Doctype作用？严格模式与混杂模式如何区分？他们有何意义？**

声明位于文档中的最前面，处于标签之前。告知浏览器以何种模式来渲染文档。

严格模式的排版和js运作模式是，以该浏览器支持的最高标准运行。

在混杂模式中，页面以宽松的向后兼容的方式显示.模拟老式浏览器的行为以防止站点无法工作。

doctype不存在或格式不正确会导致文档以混杂模式呈现

5.**src与href的区别？**

src用于替换当前元素；href用于在当前文档和引用资源之间确立联系。

src是source的缩写，指向外部资源的位置，指向的内容将会嵌入到文档中当前标签所在位置

href是Hypertext Reference的缩写，指向网络资源所在位置，建立和当前元素（锚点）或者当前文档（链接）之间的链接

6.**web前端开发中的各种居中？**

#####   水平居中

①若为**行内元素**：(父元素)text-align,(子元素)inline-block

.parent{text-align:center;}

.child{display:inline-block;}

总结：

优点：兼容性好，支持低版本浏览器

缺点：需要同时在父元素和子元素上设置

使用场景：子元素数量少（或只有一个），并且需要兼容低版本浏览器时使用，不受float影响

②块状元素：使用margin:0 auto 来实现

.child{width:200px;margin:0 auto;}

优点：兼容性好

缺点：需要指定宽度

前提：用于子元素上，不受float影响

③（子元素）display:table;margin:0 auto;

.child{display:table;margin:0 auto;}

优点：只需要对自身进行设置

缺点：不兼容IE6和IE7

使用场景：子元素数量多，不方便修改父元素的属性，对浏览器版本要求相对较低时使用

④绝对定位实现(父元素)position:relative,(子元素)absolute+left+transform(translateX(-50%))

优点：不影响其他元素

缺点：transform兼容性，IE9及以上可用

⑤flex+justify-content/margin

第一种方法：.parent{display:flex;justify-content:center;}

第二种方法：.parent{display:flex;}

​						.child{margin:0 auto;}

第一种方法：

优点：只设parent

缺点：flex兼容性差，而且比较耗资源

第二种方法：

优点：代码简单

缺点：污染父元素，flex兼容性问题，如果进行大面积的布局可能会影响效率

##### 垂直居中

①单行文本 设置line-height等于父元素高度

.child{height:20px; line-height:20px;}

优点：代码简单

缺点：只适合一行文本，多行文本则不可以

这是一种很流行的方法，也适合IE7

②行内块级元素 使用display：inline-block;vertical-align:middle;

.child{display:inline-block;vertical-align:middle}

.parent:after{display:inline-block;vertical-align:middle}

③块级元素  使用vertical-align的时候，由于对齐的基线是用行高的基线作为标记，故需要设置line-height或设置display：table-cell;

优点：兼容性比较好，换成table可以兼容IE6,7

缺点：table-cell不能和float、position：absolute同时设置（只能在外parent外套一层div.wrap才能设置float);

7.**Label的作用是什么？是怎么用的？**

label标签来定义表单控制间的关系，当用户选择该标签时，浏览器会自动将焦点转到标签相关的表单控件上。

两种用法：一种是id绑定，一种是嵌套

<label for="Name">Number:</label>

<input type=“text“name="Name" id="Name"/>

<label>Date:<input type="text" name="B"/></label>

8.**iframe框架有什么优缺点？**

优点：

①iframe能够原封不动的把嵌入的网页展现出来。

②如果有多个网页引用iframe,那么你只需要修改iframe的内容，就可以实现调用的每一个页面内的更改，方便快捷。

③网页如果为了统一风格，头部和版本都是一样的，就可以写成一个页面，用iframe来嵌套，可以增加代码的可重用。

④如果遇到加载缓慢的第三方内容如图标和广告，这些问题可以有iframe来解决。

缺点：

①框架结构中出现各种滚动条

②iframe会阻塞主页面的onload事件。

③搜索引擎的检索程序无法解读这种页面，不利于搜索引擎优化。

④iframe和主页面共享连接池，而浏览器对相同域的连接有限制，所以会影响页面的并行加载。

9.HTML与XHTML二者有什么区别，你觉得应该使用哪一个并说出理由？

应该使用XHTML，因为XHTML是XML重写了HTML的规范，比HTML更加严格，表现如下：

①XHTML中所有的标记都必须有一个相应的结束标签；

②XHTML所有标签的元素和属性的名字都必须使用小写；

③所有的xml表级都必须合理嵌套；

④所有的属性都必须用引号“”括起来；

⑤把所有<和&特殊符号用编码表示；

⑥给所有属性附一个值

⑦不要在注释内容中使用“--”；

⑧图片必须使用说明文字；

10.**HTML5的form如何关闭自动完成功能？**

将不想要自动完成的form或input设置为autocomplete=off;

11.**title与h1的区别、b与strong的区别、i与em的区别？**

title用于网站信息标题，突出网站标题或关键字，一个网站可以有多个title，SEO（搜索引擎优化）权重高与h1；h1概括的是文章主体，一个页面最好只用一个h1，seo权重低于title。

解析：

①从网站角度而言，title则重于网站信息标题，突出网站标题或关键字用title，一篇文章，一个页面最好只用一个h1，h1用得太多，会稀释主题；一个网站可以有多个title，但最好一个单页用一个title以便突出网站页面主题信息。

②从文章角度而言，h1则概括的是文章主题，突出文章主题，用h1，面对的用户，要突出其视觉效果。

③从SEO角度而言，title的权重高于h1，其适用性要比h1广。



<u>b为了加粗而加粗，strong为了标明重点而加粗；</u>

解析：

①b这个标签对应bold，即文本加粗，其目的仅仅是为了加粗显示文本，是一种样式/风格需求；

②strong这个标签意思是加强字符的语气，表示该文本比较重要，提醒读者/终端注意。为了达到这个目的，浏览器等终端将其加粗显示；



同b/strong一样，i为了斜体而斜体，em为了标明重点而斜体，且对于搜索引擎来说strong和em比b和i要重视的多。

12.**描述下seo中的TDK**

在seo中，所谓的TDK其实就是title、description、keywords这三个标签，title标题标签，description描述标签，keywords关键词标签。

13.**每个HTML文件头里都有个很重要的东西，doctype，它的作用是什么？**

<!Doctype>声明位于文档中的最前面的位置，处于 html标签之前。
①告知浏览器文档使用哪种HTML或XHTML规范。
②告知浏览器按照何种规范解析页面，如果所写的页面没有doctype的声明，那么compatmode默认就是backcompat，浏览器按照自己的方式渲染页面。
解析：浏览器本身分为两种模式，一种是标准模式，一种是怪异模式，浏览器通过doctype来区分这两种模式，doctype在HTML中的作用就是触发浏览器的标准模式，如果html中省略了doctype，浏览器就会进入到quirks模式的怪异状态，在这种模式下，有些样式会和标准模式存在差异，
14.**简述一下src与href的区别**

src用于引用资源，替换当前元素；

href用于在当前文档和引用资源之间确立联系；

解析：

href：

href标识超文本引用，用在link和a等元素上，href是引用个页面关联，是在当前元素和引用资源之间建立联系，若在文档中添加href，浏览器会识别该文档为css文件，就会并行下载资源并且不会停止对当前文档的处理。这也是问什么建议使用link方式加载css，而不是使用@import方式。

src:

src表示引用资源，替换当前元素，用在img，script，iframe上，src是页面内容不可缺少的一部分。当浏览器解析到src，会暂停其他资源的下载和处理（图片不会暂停其他资源下载和处理），直到将该资源加载、编译、执行完毕，图片和框架等也如此，类似于将所指向资源应用到当前内容，这也是问什么建议吧js脚本放在底部而不是头部的原因。

15.严格模式与混杂模式？

严格模式：以浏览器支持的最高标准运行；

混杂模式：页面以宽松向下兼容的方式显示，模拟老式浏览器的行为；

16.对于web标准以及w3c的理解与认识问题？

web标准简单来说可以分为结构、表现和行为。其中结构主要是HTML标签组成，通俗来说就是在页面body里面我们写入的标签都是为了页面的结构。表现即指css样式表，通过css可以使页面的结构标签更具美感。行为是指页面和用户具有一定的交互，同时页面结构或者表现发生变化，主要是js组成。

W3c对web标准提出了规范化的要求，也就是在实际编程中的一些代码规范：包含如下几点：

①对于结构要求：（标签规范可以提高搜索引擎对页面的抓取效率，对seo很有帮助）

1》标签字母要小写

2》标签要闭合

3》标签不允许随意嵌套

②对于css和js来说

1》尽量使用外链css样式表和js脚本。是结构与表现分离、符合规范，同时提高页面渲染速度，提高用户的体验。

2》标签的id和class等属性命名要做到见文知义，标签越少，加载越快，用户体验提高，代码维护简单，便于改版。

3》不需要变动页面内容，便可提供



17.列举IE与其他浏览器不一样的特性？

①IE的排版引擎是trident（又称为mshtml)

②tredent内核曾经几乎与w3c标准脱节（2005年）

③trident内核的大量bug等安全性问题没有得到及时解决

④js方面，有很多独立方法。例如：绑定事件的attachevent、创建时间的createEventObject等

⑤css方面，也有自己独有的处理方式。例如设置透明，低版本IE中使用滤镜的方式

18.前端页面有哪三层构成，分别是什么？作用是什么？

分为结构层、表示层、行为层。

结构层：有html或XHTML之类的标记语言负责创建。标签，也就是哪些出现在尖括号里的单词，对网页内容的语义含义作出了描述，但这些标签不包含任何关于如何有关内容的信息。

表示层：有css负责创建。css对“如何显示有关内容”的问题作出了回答

行为层：负责回答“内容有应该如何对事件做出反应”这一问题。这是JavaScript语言和dom主宰的领域。
19.**网页验证码是干嘛的，是为了解决什么安全问题？**

区分用户是计算机还是人的公共全自动程序。可以防止恶意被破解密码、刷票、论坛灌水。

有效防止黑客对某一个特定注册用户用特定程序暴力破解方式进行不断的登录尝试。

20.**对闭包的看法，为什么要用闭包？说一下闭包原理以及应用场景？**

什么是闭包：

函数执行后返回结果是一个内部函数，并被外部变量所引用，如果内部函数持有被执行函数作用域的变量，即形成了闭包。

可以在内部函数访问到外部函数作用域。使用闭包，一可以读取函数中的变量，二可以将函数中的变量存储在内存中，保护变量不被污染。而正因闭包会把函数中的变量值存储在内存中，会对内存有消耗，所以不能滥用闭包，否则会影响网页性能，造成内存泄漏。当不需要使用闭包时，要及时释放内存，可将内层函数对象的变量赋值为null。

闭包原理：

函数执行分为两个阶段（预编译阶段和执行阶段）。

在预编译阶段，如果发现内部函数使用了外部函数的变量，则会在内存中创建一个闭包对象，并保存对应变量值，如果已存在闭包，则只需要增加对应属性值即可。

执行完后，函数执行上下文会被销毁，函数对闭包现象的引用也会被销毁，但其内部函数还持用该闭包的引用，所以内部函数可以继续使用外部函数中的变量。

优点：

可以从内部函数访问外部函数的作用域中的变量，且访问到的变量长期驻扎在内存中，可供之后使用

避免变量污染全局

把变量存到独立的作用域，作为私有成员存在。

缺点：

对内存消耗有负面影响。因内部函数保存了对外部变量的引用，导致无法被垃圾回收，增大内存使用量，所以使用不当会导致内存泄漏

对处理速度具有负面影响。闭包的层级决定了引用的外部变量在查找时经过的作用域链长度

可能获取到意外的值

应用场景：

①典型应用是模块封装，在各模块规范出现之前，都是用这样的方式防止变量污染全局

②在循环中创建闭包，防止取到意外的值

21.**css伪类和伪元素区别？**

伪类：

其核心就是用来选择DOM树之外的信息，不能够被普通选择器选择的文档之外的元素，用来添加一些选择器的特殊效果。

比如：hover:active:visited:lin k :visited:first-child:focus:lang等

由于状态的变化时非静态的，所以元素达到一个特定状态时，它可能得到一个伪类的样式，当状态改变时，它又会失去这个样式。

由此可以看出，它的功能和class有些类似，但它是基于文档之外的抽象，所以叫伪类。

伪元素：

DOM树没有定义的虚拟元素

核心就是需要创建通常不存在与文档中的元素，

比如:::before  ::after 它选择的是元素指定内容，表示选择元素内容的之前内容或之后内容。

伪元素控制的内容和元素时没哟差别的，但是它本身只是基于元素的抽象，并不存在与文档中，所以称为伪元素，用于将特殊的效果添加到某些选择器。

伪类与伪元素的区别：

①表示方法：

css2中伪类、为元素都是以单冒号：表示，

css2.1后规定伪类用单冒号表示，伪元素用双冒号::表示，

浏览器同样接受css2时代已经存在的伪元素(:before,:after,:first line, :first-letter等)的单冒号写法。

css2之后所有新增的伪元素(如::selection),应该采用双冒号的写法

css3中，伪类与伪元素在语法上也有所区别，伪元素修改以::开头，浏览器以:开头的伪元素也继续支持，但建议规范书写为::开头

定义不同：

伪类即假的类，可以添加类来达到效果

伪元素即假元素，需要通过添加元素才能达到效果

总结：

伪类和伪元素都是用来表示文档树以外的“元素”

伪类和伪元素分别用单冒号:和双冒号::来表示

伪类和伪元素的区别，关键点在于如果没有伪元素（或伪类）

是否需要添加元素才能达到效果，如果是则是伪元素，反之则是伪类。

相同之处：

伪类和伪元素都不出现在源文件和DOM树中。也就是说在html源文件中是看不到伪类和伪元素的。

不同之处：

伪类其实就是基于普通DOM元素而产生的不同状态，它是DOM元素的某一特征。

伪元素能够创建在DOM树中不存在的抽象对象，而且这些抽象对象是能够访问的。

22.**css基础选择器：标签选择器、id选择器、类选择器、通配符选择器。**

作用和优缺点：

标签选择器：

作用：标签选择器可以把某一类标签全部找出来，比如所有的<div>标签和所有的<span>标签

优点：能快速为页面中同类型的标签统一设置样式

缺点：不能设计差异化样式，只能选择全部的当前标签

id选择器：

作用：一次只能选择1个标签

特点：id属性只能在每个html文档中出现一次。

类选择器：

作用：可以选出1个或者多个标签

特点：可以根据需求选择

统配父选择器：

作用：选择所有的标签

特点：选择的太多，有部分不需要；

![img](file:///C:\Users\梦飞蓝天\Documents\Tencent Files\2992275490\Image\C2C\I9M)N6Q$Y1@{MB9UA6JH4L8.png)

![img](file:///C:\Users\梦飞蓝天\Documents\Tencent Files\2992275490\Image\C2C\UBH8D67CWCZCGI]]J$UFTT9.png)

![img](file:///C:\Users\梦飞蓝天\Documents\Tencent Files\2992275490\Image\C2C\I9M)N6Q$Y1@{MB9UA6JH4L8.png)

复合选择器总结：

后代选择器：作用：用来选择后代元素、特征：可能是子孙后代；隔开符号及用法：符号是空格  .nav a

子代选择器：作用：选择最近一级元素。特征：只能亲儿子；隔开符号及用法：符号是大于 .nav>p

并集选择器：作用：选择某些相同样式的元素。特征：可以用于集合声明；隔开符号及用法：符号是逗号 .nav,.header

链接伪类选择器：作用：选择不同状态的链接。特征：跟链接相关；隔开符号及用法：重点记住a{}和a:hover 实际开发的写法

:focus选择器：作用：选择获得光标的表单。特征：跟表单相关。隔开符号及用法：input:focus记住这个写法

23. **为什么要清除浮动？**

    由于父级盒子很多情况下，不方便给高度，但是子盒子浮动又不占有位置，最后父级盒子高度为0时，就会影响下面的标准流盒子。

    专业解释：由于浮动元素不再占有原文档流的位置，所以它会对后面的元素排版产生影响

    24. **清除浮动的方法：**

额外标签法（隔墙法）、给父元素添加overflow:hidden、after伪元素法、双伪类法。

①额外标签法：会在浮动元素末尾添加一个空的标签。例如<div style="clear:both"></div>

优点：通俗易懂，书写方便；

缺点：添加许多无意义的标签，结构化较差。

注意：要求这个新的空标签必须是块级元素。

②父级添加overflow，：将其属性值设置为hidden、auto或scroll.子不教，父之过，注意是给父元素添加代码

优点：代码简洁

缺点：无法显示溢出的部分 

③after伪元素法：:after方式是额外标签法的升级版。也是给父元素添加。

优点：没有增加标签，结构更简单，

缺点：照顾低版本浏览器

代表网站：百度、淘宝网、网易等

④双伪元素清除浮动

优点：代码更简洁

缺点：照顾低版本浏览器

代表网站：小米、腾讯等

25. 导航栏以及其他页面中a链接的注意事项：

    实际开发中，不会直接用链接a，而是用li包含链接(li+a)的做法。

    原因：①li+a语义更清晰，一看这就是有条理的列表型内容

    ②如果直接用a，搜索引擎容易辨别为有堆砌关键字嫌疑（故意堆砌关键字容易被搜索引擎有降权的风险），从而影响网站排名。

    26. 固定定位小技巧：固定在版心右侧位置

        小算法：①让固定定位的盒子left:50%,走到浏览器可视区(也可以看做版心)的一半位置。

        ②让固定定位的盒子margin-left：版心宽度的一半距离。多走版心宽度的一半位置就可以让固定定位的盒子贴着版心右侧对齐了。

        实测提示：margin-left:-10与margin-right:10效果不同。

        27. 粘性定位sticky

            粘性定位是相对定位和固定定位的混合，

            语法：选择器{position：sticky; top:10px;}

            特点：

            ①以浏览器的可视窗口为参照点移动元素（固定定位特点）

            ②粘性定位占有原先的位置（相对定位特点）

            ③必须添加top/left/right/bottom其中一个才有效

28. 表单form中method的两种属性get 和post两种提交数据的http方法作用与区别？

    get方式将表单内容附加到URL地址后面，因此对提交信息的长度有限制。同时get方式不具备保密性，表单内容在URL地址中以明文的形式显示。

    post方式可将用户在表单中填写的数据包含在表单的主体中，一起传送给服务器上的处理程序，没有提交信息长度的限制，保密性也较好。

    默认情况下，表单使用get方式传送数据。

29. ### **什么是响应式页面设计？**

    响应式网站设计（RWD)(responsive web design)是一种网络页面设计布局，页面的设计与开发应当根据用户行为以及设备环境（系统平台、屏幕尺寸、屏幕定向等）进行相应的相应和调整。

    描述响应式界面最著名的一句话：“content is like water"

    大白话：如果将屏幕看作容器，那么内容就像水一样。

    **响应式网站常见特点：**

    ①同时适配PC+平板+手机等

    ②标签导航在接近手持终端设备时改变为经典的抽屉式导航

    ③网站的布局会根据视口来调整模块的大小和位置

    **实现方式：**

    响应式设计的基本原理是通过媒体查询检测不同的设备屏幕尺寸做处理，为了处理移动端，页面头部必须由meta声明viewport

    **实现响应式布局的方式有如下：**

    媒体查询、百分比、vm/vh、rem

    **优点：**

    面对不同分辨率设备灵活性强

    能够快捷解决多设备显示适应问题

    **缺点：**

    仅适用布局、信息、框架并不复杂的部门类型网站

    兼容各种设备工作量大，效率低下

    代码累赘，会出现隐藏无用的元素，加载时间加长

    其实这是一种折中性质的设计解决方案，多方面因素影响而达不到最佳效果

    一定程度上改变了网站原有的布局结构，会出现用户混淆的情况。

    **常见的响应式页面设计技术有哪些？**

    视口、媒体查询、流体布局、弹性布局、bootstrap框架、

28. ### **如何让一个盒子水平垂直居中**	

    html代码如下：

    ![img](https://img2018.cnblogs.com/blog/1506553/201907/1506553-20190718095337425-542969881.png)

    固定样式：

    ![img](https://img2018.cnblogs.com/blog/1506553/201907/1506553-20190718095816542-668467039.png)

    方法一：利用定位（常用方法,推荐）

    .parent{

    position:relative;

    }

    .child{

    position:absolute;

    top:50%;

    left:50%;

    margin-top:-50px;

    margin-left:-50px;

    }

    方法一的原理就是定位中心点是盒子的左上顶点，所以定位之后我们需要回退盒子一半的距离。

     

    方法二：利用margin:auto;

    .parent{

    position:relative;

    }

    .child{

    position:absolute;

    margin:auto;

    top:0;

    left:0;

    right:0;

    bottom:0;

    }

    方法三：利用display:table-cell;

    是指让标签元素以表格单元格的形式呈现，使元素类似于td标签

    .parent{

    display:table-cell;

    vertical-align:middle;

    text-align:center;

    }

    .child{

    display:inline-block;

    }

    方法四：利用display：flex;设置垂直水平都居中；

    .parent{

    display:flex;

    justify-content:center;

    align-items:center;

    }

    方法五：计算父盒子与子盒子的空间距离(这跟方法一是一个道理)；

    计算方法：父盒子高度或者宽度的一半减去子盒子高度或者宽的的一半。

    .child{

    margin-top:200px;

    margin-left:200px;

    }

    方法六：利用transform

    .parent{

    position:relative;

    }

    .child{

    position:absolute;

    top:50%;

    left:50%;

    transform:translate(-50%,-50%);

    }

    方法七：利用calc计算

    .parent{

    position:relative;

    }

    .child{

    position:absolute;

    top:calc(200px);//（父元素高-子元素高）÷ 2=200px

    let:calc(200px);//（父元素宽-子元素宽）÷ 2=200px

    }

29. ### 弹性布局（display：flex）属性详解

Flexbox是flexible box的简称（注：意思是“灵活的盒子容器"),是css3引入的新的布局模式。它决定了元素如何在页面上排列，使它们能在不同的屏幕尺寸和设备下可预测地展现出来。

它之所以被称为Flexbox，是因为它能够扩展和收缩flex容器内的元素，以最大限度地填充可用空间 。与之前布局方式（如table布局和浮动元素内嵌块元素）相比，Flexbox是一个更强大的方式：

①在不同方向排列元素

②重新排列元素的显示顺序

③更改元素的对其方式

④动态地将元素装入容器

## 一、基本概念

采用 Flex 布局的元素，称为 Flex 容器（flex container），简称"容器"。它的所有子元素自动成为容器成员，称为 Flex 项目（flex item），简称"项目"。

![img](https://img2018.cnblogs.com/blog/1287814/201902/1287814-20190227105227947-1509987029.png)

在 Flexbox 模型中，有三个核心概念：
– flex 项（注：也称 flex 子元素），需要布局的元素
– flex 容器，其包含 flex 项
– 排列方向（direction），这决定了 flex 项的布局方向

 

##  二、容器属性

![img](https://img2018.cnblogs.com/blog/1287814/201902/1287814-20190227105554256-71254015.png)

 

### 2.1 flex-direction:

- row（默认值）：主轴为水平方向，起点在左端。
- row-reverse：主轴为水平方向，起点在右端。
- column：主轴为垂直方向，起点在上沿。
- column-reverse：主轴为垂直方向，起点在下沿。

![img](https://img2018.cnblogs.com/blog/1287814/201902/1287814-20190227112100971-1704943994.png)

 

 

### 2.2  flex-wrap:

- nowrap（默认）：不换行。
- wrap：换行，第一行在上方。
- wrap-reverse：换行，第一行在下方。

 

### 2.3 justify-content:

- flex-start（默认值）：左对齐
- flex-end：右对齐
- center： 居中
- space-between：两端对齐，项目之间的间隔都相等。
- space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。

![img](https://img2018.cnblogs.com/blog/1287814/201902/1287814-20190227115738642-2112201313.gif)

### 2.4 align-items:

- flex-start：交叉轴的起点对齐。
- flex-end：交叉轴的终点对齐。
- center：交叉轴的中点对齐。
- baseline: 项目的第一行文字的基线对齐。
- stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。

![img](https://img2018.cnblogs.com/blog/1287814/201902/1287814-20190227134053190-1350217843.gif)

### 2.5 align-content:

定义了多根轴线的对齐方式，如果项目只有一根轴线，那么该属性将不起作用

- flex-start：与交叉轴的起点对齐。
- flex-end：与交叉轴的终点对齐。
- center：与交叉轴的中点对齐。
- space-between：与交叉轴两端对齐，轴线之间的间隔平均分布。
- space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。
- stretch（默认值）：轴线占满整个交叉轴。

 

![img](https://img2018.cnblogs.com/blog/1287814/201902/1287814-20190227134814322-88632295.png)

### 结合 `justify-content`和`align-items`，看看在 `flex-direction` 两个不同属性值的作用下，轴心有什么不同：

![img](https://img2018.cnblogs.com/blog/1287814/201902/1287814-20190227134239511-1709887438.gif)

##  三、项目属性

![img](https://img2018.cnblogs.com/blog/1287814/201902/1287814-20190227135037726-1170549985.png)

 

## 3.1 order属性

![img](https://img2020.cnblogs.com/blog/1287814/202008/1287814-20200814180820136-1259976518.png)

 

 

## 3.2 flex-grow属性

`flex-grow`属性定义项目的放大比例，默认为`0`，即如果存在剩余空间，也不放大。

 

如果所有项目的`flex-grow`属性都为1，则它们将等分剩余空间（如果有的话）。如果一个项目的`flex-grow`属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。

![img](https://img2020.cnblogs.com/blog/1287814/202008/1287814-20200814180912736-504097544.png)

 

 

## 3.3 flex-shrink属性

`flex-shrink`属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。

```
.item {
  flex-shrink: <number>; /* default 1 */
}
```

 

![img](http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071015.jpg)

 

如果所有项目的`flex-shrink`属性都为1，当空间不足时，都将等比例缩小。如果一个项目的`flex-shrink`属性为0，其他项目都为1，则空间不足时，前者不缩小。

负值对该属性无效。

 

## 3.4 align-self属性

`align-self`属性允许单个项目有与其他项目不一样的对齐方式，可覆盖`align-items`属性。默认值为`auto`，表示继承父元素的`align-items`属性，如果没有父元素，则等同于`stretch`。

```
.item {
  align-self: auto | flex-start | flex-end | center | baseline | stretch;
}
```

![img](https://img2020.cnblogs.com/blog/1287814/202008/1287814-20200814180755315-1277154942.png)

**弹性布局默认不改变项目的宽度，但是它默认改变项目的高度。如果项目没有显式指定高度，就将占据容器的所有高度。**

参考：http://www.ruanyifeng.com/blog/2018/10/flexbox-form.html

http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html

### 30.transform：translate(-50%,-50%）实现水平垂直居中

translate()函数是css3的新特性，在不知道自身宽高的情况下，可以利用它来进行水平垂直居中。当使用：top:50%,left:50%，是以左上角为原点，故不处于中心位置

translate(-50%,-50%)作用是，往上(x轴)，左(y轴)移动自身长宽的50%，以使其居于中心位置。

此方法与margin-left和margin-top实现居中不同的是，margin-left必须知道自身的宽高，而translate可以在不知道宽高的情况下进行居中，translate()函数中的百分比是相对于自身宽高的百分比，所以能进行居中。



