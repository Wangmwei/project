https的ssl加密是在传输层实现的

http和https的基本概念

http:超文本传输协议，是互联网上应用最为广泛的一种网络协议，是一个客户端和服务器端请求和应答的标准，（TCP)，用于从www服务器传输超文本到本地浏览器的传输协议，它可以使浏览器更加高效，使网络传输减少

https是以安全为目标的http通道，简单讲是http的安全版，即http下加入ssl层，https的安全基础是ssl，因此加密的详细内容就需要ssl、

https协议的主要作用是：建立一个信息安全通道，来保证数组的传输，确保网站的真实性。

http和https的区别？

http传输的数据都是未加密的，也就是明文的，网景公司设置了ssl协议来对http协议传输的数据进行加密处理，简单来说https协议是有http和ssl协议构建的可进行加密传输和身份认证的网络协议，安全性更高

主要的区别如下：

https协议需要ca证书，费用较高

http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。使用不同的链接方式，端口也不同，一般而言，http协议的端口为80，https的端口为443

http的链接很简单，是无状态的，https 的协议是由ssl+http协议构建的可进行加密传输，身份认证的网络协议，比http协议安全性更高

https协议的工作原理：

客户端在使用https方式与web服务器通信是有以下几个步骤，如图所示，

客户使用https url访问服务器，则要求web服务器建立ssl连接。

web服务器接收到客户端的请求之后，会将网站的证书（证书中包含了公钥），返回或者说传输给了客户端

客户端和web服务器端开始协商ssl连接的安全等级，也就是加密等级

客户端浏览器通过双方协商一致的安全等级，建立会话秘钥，然后通过网站的公钥来加密 会话秘钥，并传送给网站

web服务器通过自己的私钥解密出会话密钥

web服务器通过会话密钥与客户端之间的通信

https协议的优点：

使用https协议可认证用户和服务器，确保数据发送到正确的客户机和服务器；

https协议是有http+ssl协议构建的可进行加密传输，身份认证的网络协议，要比http协议安全，可防止数据在传输过程中不被窃取，改变，保证数据的完整性。

https是现行架构下最安全的解决方案，虽然不是绝对安全的，但是它大幅增加了中间人攻击的成本。

谷歌曾在2014年8月份调整搜索引擎算法，并称“比起同等http网站，采用https加密的网站在搜索结果中的排名将会更高

https协议的缺点：

https握手阶段比较费时，会使页面加载时间延长50%，增加10%~20%的耗电

https缓存不如http高效，会增加数据开销

ssl证书也需要钱，功能越强大的证书费用更高

ssl证书需要绑定ip，不能再同一个ip上绑定多个域名，ipv4资源支持不了这种消耗





tcp是面向连接的，udp是无连接的，即发送数据之前不需要先建立连接

tcp提供了可靠的服务，也就是说，通过tcp连接传送的数据，无差错，不丢失，不重复，且按序到达；

而udp是尽最大努力交付，即不保证可靠交付，

因为tcp可靠，面向连接，不会丢失数据，因此适合大数据量的交换



tcp是面向字节流，udp面向报文，并且网络出现拥塞不会使得发送速率降低，因为会出现丢包，对实时的应用比如ip电话和视频会议等

tcp只能是1对1的，而udp可以1对1，也可以1对多

tcp的首部较大，为20字节，而udp只有8字节

tcp是面向连接的可靠性传输，而udp是不可靠的





tcp  

面向字节流的，面向连接的，可靠的，无差错的，不丢失，不重复的，一种数据传输方式，其首部较大，为20个字节，，因此适合较大数据量的交换。

只支持一对一的



udp 

面向报文的，无连接的，即发送数据前不需要先建立链接，尽可能保证传输，即不能保证传输数据的可靠性，其首部长度为8字节，

网络出现拥塞不会使得发送速率降低，因为会出现丢包，对实时的应用比如ip电话和视频会议等



支持一对一   一对多





tcp

面向连接的，面向字节流的，可靠的，无差错的，不丢失的，不重复，且按序到达，的一种数据传输方式，仅支持一对一传输，其首部长度较大，为20个字节，因此常用来大数据量之间的传输

udp

面向无连接的，即数据传输之前不需要提前建立连接，

面向报文的，因此网络出现拥塞时不会使得发送效率降低，因此会出现丢包的现象

它是一种尽最大努力提供可靠传输的，即传输不能保证可靠交付，其首部长度为8字节，支持一对一传输，一对多传输。



状态码：

400  状态码：请求无效

产生原因：

前端提交数据的字段名称和字段类型与后台的实体没有保持一致

前端提交到后台的数据应该是json字符串类型，但是前端没有将对象json.stringify转换成字符串。

解决方法：

对照字段的名称，保持一致性

将obj对象通过json.stringify实现序列化

401状态码：当前请求需要用户验证

403状态码：服务器已经得到请求，但是拒绝执行

401状态码：当前请求需要用户验证

403状态码：服务器已经得到了请求，但是拒绝执行



400状态码：请求无效：

产生原因

前端提交数据的字段名和字段类型与后台的实体没有保持一致

前端提交到后台的数据应该是json字符串类型，但是前端并没有将对象json.stringify转化成字符串

解决方法：

对照字段的名称，保持一致性

将obj对象通过json.stringify实现序列化

401状态码：当前请求需要用户验证

403状态码：服务器收到请求，但是拒绝执行

400状态码：请求无效；

产生原因：

前端提交数据的字段名称和字段类型与后台的实体没有保持一致。

前端提交到后台的数据应该是json字符串类型，但是前端没有将对象json.stringify转化为字符串。

解决方法：

对照字段的名称，保持一致性。

400状态码：请求无效：

产生原因：

前端提交数据的字段名和字段类型与后台的实体没有保持一致。

前端提交到后台的数据应该是json字符串类型，但是前端没有将对象json.stringify的类型转化为字符串

解决方法：

对照字段的名称，保持一致性。

400状态码：请求无效

产生原因：

前端提交数据的字段名和字段类型与后台的实体没有保持一致，

前端提交到后台的数据应该是json字符串类型，但是前端没有将对象json.stringify转化为字符串

解决方法：

对照字段的名称，保持一致性

400；请求无效

401：当前请求需要得到用户的验证

403：服务器收到了请求，但是拒绝执行

coolie  session  sessionStorage  localStorage

coolie  在客户端  session在服务器端

cookie是浏览器和服务器间来回传递。

而sessionStorage和localStorage不会自动吧数据发给服务器，尽在本地保存，cookie数据还有路径的概念，可以限制cookie只属于某个路径下，存储的大小很小，只有4k左右，



重点@cookie

cookie是在浏览器和服务器端来回传递，存储容量小，只有大约4k左右，

sessionStorage和localStorage不会自动吧数据发送给服务器，仅在本地保存。

sessionStorage和localStorage不会自动把数据发送给服务器，仅在本地保存。

sessionStorage和localStorage不会自动把数据发送给服务器，仅在本地保存

sessionStorage：仅在当前浏览器窗口关闭前有效，不能持久保存

localStorage:除非手动清除，否则永久有效；

cookie：没设置过期时间时，关闭页面即失效，设置过期时间时，在过期时间之前有效







对HTML语义化标签的 理解！！

HTML5语义化标签是指正确的标签包含了正确的内容，结构良好，便于阅读，

比如：nav  一看就是导航条的意思

header一看就是头部的意思等等





html语义化标签的理解

html5语义化标签是指正确的标签包含了正确的内容，结构良好，便于阅读，





doctype的作用  

doctype声明与文档最前面，告诉浏览器以何种方式、何种模式来渲染页面

严格模式

严格模式的排版以及js运作模式是以该浏览器支持的最高标准运行

混杂模式

混杂模式，向后兼容，即模拟老式浏览器，是为了阻止浏览器无法兼容页面





doctype 的作用

doctype声明与文档的最前面，用于告知浏览器以何种方式何种模式来渲染页面

严格模式

严格模式：是以当前浏览器的最高标准来执行的

严格模式的排版和js运作模式是以浏览器支持的最高标准运行的

混杂模式

混杂模式采用向后兼容的方式，即模拟老式浏览器的标准来运行，防止浏览器无法兼容页面



cookie如何防范xxs攻击

xxs跨域脚本攻击，是指攻击者在返回的html中嵌入了JavaScript脚本的攻击方式

为了减轻这些攻击，需要在http头部配上set-cookie:httponly

这个属性可以防止xxs，它会禁止JavaScript脚本来访问cookie

secure这个属性告诉浏览器仅在请求为https的时候发送cookie

set-cookie=<cookie-value>



cookie防范xxs攻击



xxs攻击跨越脚本攻击，是指攻击者在返回的http中嵌入了JavaScript脚本的攻击方式

为了减轻这些攻击，需要在http头部配上httponly 这个属性可以防止xxs，它会禁止JavaScript脚本来访问cookie,secure这个属性告诉浏览器仅在请求为https的时候发送



cookie如何防范xxs攻击

xxs跨域脚本攻击，是指攻击者在返回的html中嵌入了JavaScript脚本的攻击方式为了减轻这些攻击，需要在http头部配上httponly

这些属性可以防止xxs,它会禁止JavaScript脚本来访问cookie

secure这个属性告诉浏览器仅在请求为https的时候发送cookie

400 :请求无效

产生原因：

前端传送数据的字段名和字段类型与后台的实体不一致

401  当前请求需要得到用户的验证

addEventListener(event,function useCapture)

event 是指定事件名，function 指定要事件触发时执行的函数，useCapture指定事件是否在捕获或冒泡阶段执行



100  continue 继续。客户端应继续其请求，

100 continue 继续，客户端应继续其请求

200 ok 请求成功，一般用于get和post请求

201create 已创建 成功请求并创建了新的资源

202 accepted 已接收，已经接受请求，但未处理完成



302  Found 临时移动  与301类似，但是资源只是临时被移动，客户端应继续使用原有URL

304：如果客户端发送了一个带条件的get请求且该请求已被允许，而文档的内容

前端优化：

降低请求量：合并资源，减少http请求数，minify/gzip压缩，lazyload 

加快请求速度：预解析DNS，减少域名数，并行加载，

get参数

get参数通过url传递，post放在request body中

get请求在url中传递的参数是有长度限制的，而post没有

get比post更不安全，因为参数直接暴露在url中，所以不能用来传递敏感信息

get请求只能进行url编码，而post支持多种编码方式

get请求会浏览器主动cache，而post支持多种编码方式

get请求参数会被完整保存在浏览历史记录中，而post中的参数不会被保留

get和post本质上就是TCP链接，并无差别，但是由于http的规定和浏览器/服务器的限制，导致他们在应用过程中体现出一些不同

get产生一个TCP数据报，post产生两个TCP数据包

浏览器缓存分两种，强缓存和协商缓存，根据相应的header内容来决定的

强缓存相关字段有expires，cach-control，如果cache-control与expires同时存在的话，cache-control的优先级高于expires

协商缓存相关字段有···



在地址栏中输入一个url，到这个页面呈现出来，中间会发生什么：

输入url后，首先需要找到这个url域名的服务器ip，为了寻找这个ip,浏览器首先会寻找缓存，查看缓存中是否有记录，缓存的查找记录为：浏览器缓存》系统缓存》路由器缓存，缓存中没有则查找系统的hosts文件中是否有记录，如果没有则查询DNS服务器，得到服务器的ip地址后，浏览器根据这个ip以及相应的端口号，构造一个http请求，这个请求报文会包括这次请求的信息，主要是请求方法，请求说明和请求附带的数据，并将这个http请求封装在一个tcp包中，这个tcp包会依次经过传输层，网络层，数据链路层，物理层到达服务器，服务器解析这个请求来做出响应，根据返回的html给浏览器，因为html是一个树形结构，浏览器根据这个html来构建DOM树，在dom树的构建过程中如果遇到js脚本和外部JS连接，则会停止构建dom树来执行和下载响应的代码，这会造成阻塞，这就是为什么推荐JS代码应该放在html代码的后面，之后根据外部样式，内部样式，内联样式构建一个css对象模型书cssom树，构建完成后和DOM树合并为渲染树，这里主要做的是排出非视觉结点，比如script，meta标签和排出display为none 的结点，之后进行布局，布局主要是确定各个元素的位置和尺寸，之后是渲染页面，因为html文件中会含有图片，视频，音频等资源，在解析DOM的过程中，遇到这些问题都会进行并行下载，浏览器对每个域的并行下载数量有一定的限制，一般是4-6个，当然在这些所有的请求中我们还需要关注的就是缓存，缓存一般通过cache-control，Last-Modify，Expires等首部字段控制，



浏览器在生成页面的时候，会生成那两棵树



构造两棵树  DOM树和cssom规则树

当浏览器接收到服务器相应来的html文档后，会遍历文档结点，生成dom树，cssom规则树由浏览器解析css文件生成。

DNS解析---TCP连接--发送http请求--服务器处理请求并返回http报文--浏览器解析渲染页面--连接结束



cookie数据存放在客户的浏览器上，session数据放在服务器上，

cookie不是很安全，别人可以分析存放在本地的cookie并进行cookie欺骗考虑到安全应当使用session

session会在一定时间内保存在服务器上，当访问增多，会比较占用你服务器的性能考虑到减轻服务器性能方面，应当使用cookie

当个cookie保存的数据不能超过4k，很多浏览器都限制一个站点最多保存20个cookie





cookie数据存放在客户的浏览器上，session数据存放在服务器上

cookie不是很安全，别人可以分析存放在本地的cookie并进行cookie欺骗，考虑到安全应当使用session

session会在一定时间内保存在服务器上，当访问增多，会比较占用你服务器的性能，考虑到减轻服务器性能方面，应当使用cookie

单个cookie保存的数据不能超过4k，很多浏览器都限制一个站点最多保存20个cookie





cookie  

存放在客户的浏览器上，不是很安全，别人可以分析存放在本地的cookie并进行cookie欺骗，考虑到安全应当使用session，，单个cookie保存的数据不能超过4k，很多浏览器都限制一个站点最多保存20个cookie



session 

存放在服务器上，会在一定时间内保存在服务器上，当访问增多，会比较占用你服务器的性能，考虑到减轻服务器性能方面，应当使用cookie







cookie  

cookie数据存放在客户端，不是很安全，别人可以分析存放本地的cookie并进行cookie欺骗，考虑到安全应当使用session

单个cookie保存的数据不能保存4k，很多浏览器都限制一个站点最多保存20个cookie。

session

session数据存放在服务器上，当访问增多，会比较真用你服务器性能，考虑到减轻服务器性能方面，应当使用cookie



304：如果客户端发送了一个带条件的get请求且该请求已经被允许，而文档的内容（自上次访问以来或者根据请求的条件）并没有改变，则服务器应当返回这个304状态码。



dns解析，tcp连接，发送http请求，服务器处理请求并返回http报文，浏览器解析渲染页面，连接结束

dns解析，tcp连接，发送http请求，服务器处理请求并返回http报文，浏览器解析渲染页面，连接结束

dns解析，tcp连接，发送http请求，服务器处理请求并返回http报文，浏览器解析渲染页面，连接结束





传统的标准盒子



transition 和animation区别

animation 和 transition大部分属性是相同的，他们都是随时间改变的属性值，他们主要的区别是transition 需要触发一个事件才能改变属性，而animation不需要触发任何事件的情况下才会随时间改变属性值，并且transition为2帧，从from   to 而animation可以一帧一帧

首先，这两个属性大体相同，都是随时间改变值               

transition  

需要触发一个事件才能改变   transition为2帧

animation  

不需要触发任何事件的情况下才会随时间改变属性值

animation 可以一帧一帧



BFC块级格式化上下文，用于清除浮动，防止margin重叠等

BFC块级格式化上下文，是一个独立的渲染区域，并且有一定的布局规则。

BFC区域不会与float box重叠

BFC是页面上的一个独立容器，子元素不会影响到外面

计算BFC的高度时，浮动元素也会参与计算

哪些元素会生成BFC

float部位none的元素

position为fixed和absolute的元素

display为inline-block/table-cell/table-caption flex  inline-flex;

overflow部位visiblt的元素

垂直居中的方法：

margin:auto 法

css:

div{

width:400px;

height:400px;

posiitonLrelative;

border:1px solid red;

}

img{

position:absolute;

margin:auto;

top:0;

left:0;

bottom:0;

right:0;
}

table-cell(未脱离文档流的)

设置父元素的display：table-cell，并且vertical-align:middle 

这样子元素可以实现垂直居中

水平居中用text-align:center;



flex:

父元素设置display:flex; 

align-items:center;

justify-content:center;



第一种方法：

margin：auto;让上下左右都设置为0；脱离文本流，然后margin:auto上下左右都居中就实现了垂直居中

第二种方法：

margin负值法；

top:50%；

left:50%;

margin-top:-盒子高度一半

margin-left:-盒子宽度一半

或者用translate（-50%）

第三种方法：display:table-cell;

父：

display:table-cell

vertical-align:middle;

text-align:center;

子：

display:block;

第四种方法：

display:flex;

align-items:center;

justify-content:center;





块元素和行元素



块元素：独占一行，并且有自动填充父元素，可以设置margin和padding，

以及宽高

行元素：不会独占一行，width和height会失效，并且在垂直方向的padding和margin会丢失



多行文本的省略号

diaplay:-webkit-box;

-webkit-box-orient:vertical

-webkit-line-clamp:3;

overflow:hidden;



visibility=hidden,opacity=0,display:none;

可见， 透明度，隐藏。

opacity=0;该元素隐藏起来，但是不会改变页面布局，并且，如果该元素已经绑定一些事件，如click，那么点击该区域，也能触发点击事件的，

visibility=hidden，该元素隐藏起来了，但不会改变页面布局，但是不会触发该元素已经绑定了的事件，

display=none，把元素 隐藏起来，并且会改变页面布局，可以理解成在页面中把该元素删掉一样、、

三个隐藏

opacity:0;

将透明度设置为0，元素隐藏起来，但仍然占据原有位置，不会改变页面布局，如果该元素绑定了一些事件，那也能通过相应的event进行触发

visibility:hidden

可见度属性设置为隐藏，不会触发该元素已经绑定的事件

display=none，

把元素隐藏起来，并且会改变页面布局，可以理解成在页面中把该元素删掉一样







异步加载js的方法：

defer:只支持IE如果您的脚本不会改变文档的内容，可将defer属性加到script标签中，以便加快处理文档的速度，因为浏览器知道它将能够安全地读取文档的剩余部分而不用执行脚本，它将推迟对脚本的解释，直到文档已经显示给用户为止

async,HTML5属性仅适用于外部脚本，并且如果在IE中，同时存在defer和async，那么defer的优先级比较高，脚本将在页面完成执行



JS中的垃圾回收机制：

必要性：由于字符串，对象，数组没有固定大小，所以当他们的大小已知时，才能对他们进行动态的存储分配，JavaScript程序每次创建字符串，数组或对象时，解释器都必须分配内存来存储那个实体，只要像这样动态的分配了内存，最终都要释放这些内存以便他们能够被再用，否则，JavaScript的解释器将会消耗完系统中所有可用的内存 ，造成系统崩溃

js不像c/c++,他有自己的一套垃圾回收机制，JavaScript的解释器可以检测到何时程序不再使用 一个对象了，当他确定了对象是无用的时候，就不需要这个对象，可以把它所占有的内存释放掉，例如：

var a="hello word"

var b="world"

var a=b;

这时，会释放掉hello world，释放内存以便在引用 

垃圾回收的方法：标记清除，计数引用

标记清除

这是最常见的垃圾回收方法，当变量进入环境时，就标记这个变量为《j

进入环境，从逻辑上讲，永远不能释放进入环境的变量所占有的内存，只有执行流程进入相应的环境，就可能用到他们，当离开环境时，就标记为离开环境，垃圾回收器在运行的时候会给存储在内存中的变量都加上标记，所有都加，然后去掉环境变量中的变量，以及被环境变量所引用的变量，条件性去除标记，删除所有被标记的变量，删除的变量无法在环境变量中被访问，最后垃圾回收器，完成了内存的清除工作，并回收他们所占用的内存



标记清除法：

当变量进入环境时，就标记这个变量进入环境，从逻辑上讲，永远不能释放进入环境的变量所占的内存，永远不能释放进入环境变量所占用的内存，只要执行流程进入相应的环境，就可能用到他们，当离开环境时，就标记为离开环境，垃圾回收器在运行的时候会给存储在内存中的变量都加上标记（所有都加），然后去掉环境变量中的变量，以及被环境变量中的变量所引用的变量，（条件性去除标记），删除所有被标记的变量，删除的变量无法在环境变量中被访问所以会被删除，最后垃圾回收器完成了内存的清除工作，并回收了他们所占用的内存、



用于字符串，数组，对象没有固定的大小，当他们的大小已知时，才能对他们进行动态的存储分配，JavaScript程序每次创建字符串，数组，或对象时，解释器都必须分配内存 来存储那个实体，只要像这样动态地分配了内存，最终都要释放这些内存以便他们能够被再用，否则，JavaScript的解释器将会消耗完系统中所有可用的内存，造成系统崩溃



由于字符串，数组，对象没有固定的大小，当他们的大小已知时，才能对他们进行动态的存储分配，JavaScript程序每次创建字符串，数组，对象时，解释器都必须分配内存来存储那个实体，只要像这样动态的分配了内存，最终都要释放这些内存以便他们能够被再用，否则，JavaScript的解释器将会消耗完系统中所有可用的内存，造成系统崩溃





由于字符串，数组，对象没有固定的大小，当他们的大小已知时，JavaScript解释器需要对他们进行动态的分配以存储相应的实体，JavaScript程序每次创建字符串，数组和对象时，解释器都必须分配内存来存储那个实体，只要像这样动态地分配了内存，最终都要释放这些内存以便他们能够被再用，否则，JavaScript的解释器将会消耗完系统中所有可用的内存，造成系统崩溃



前端模块化：

前端模块化就是复杂的文件变成一个一个独立的模块

比如js文件等等，分成独立的模块有利于重用和维护，重用性，版本迭代，这样会引来模块之间相互依赖的问题，所以有了commonjs的规范，AMD, CMD规范等，以及用于JS打包的工具是webpack



前端模块化：

前端模块化就是复杂的文件变成一个一个独立的模块

比如JS文件等等，分成独立的模块有利于重用和维护。

这样会引来模块之间的相互依赖问题，所以有了

commonJS规范，AMD,CMD规范等，以及用于JS打包（

编译等处理）的工具webpack



commonJS AMD  CMD

一个模块是能实现特定功能的文件，有了模块就可以方便的使用别人的代码，想要什么功能就加载什么模块

commonJS   开始与服务器端的模块化，同步定义的模块化，没个模块都是一个单独的作用域，模块输出，modules.exports，模块加载require()引入模块



AMD  中文名异步模块定义的意思。

requeireJS实现 了AMD规范，主要用于解决了两个问题：

一，多个文件有依赖关系，被依赖的文件需要过早于依赖它的文件加载到浏览器

二，加载的时候浏览器会停止页面渲染，加载文件越多，页面失去响应的时间越长，

 总结AMD规范：require()函数在加载依赖函数的时候是异步加载的，这样浏览器不会失去响应，它指定的回调函数，只有前面的模块加载功能，才会去执行。

因为网页在加载js的时候会停止渲染，因此我们可以通过异步的方式去加载js，而如果需要依赖某些，也就是异步依赖，依赖后再执行某些方法



























































































































































































































0j 



































